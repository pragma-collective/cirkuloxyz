{
  "address": "0x2b3Bf926948E5ff1742239130028Bdb6FD2B4614",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "initialOwner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_roscaImpl",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_savingsImpl",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_donationImpl",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "ERC1167FailedCreateClone",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "OwnableInvalidOwner",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "OwnableUnauthorizedAccount",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "string",
          "name": "poolType",
          "type": "string"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newImplementation",
          "type": "address"
        }
      ],
      "name": "ImplementationUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "circleId",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "poolAddress",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "creator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "enum XershaFactory.PoolType",
          "name": "poolType",
          "type": "uint8"
        }
      ],
      "name": "PoolCreated",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "allPools",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "circleToPool",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "circleId",
          "type": "address"
        },
        {
          "internalType": "string",
          "name": "circleName",
          "type": "string"
        },
        {
          "internalType": "address",
          "name": "beneficiary",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "goalAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "deadline",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "tokenAddress",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "isNativeToken",
          "type": "bool"
        }
      ],
      "name": "createDonationPool",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "circleId",
          "type": "address"
        },
        {
          "internalType": "string",
          "name": "circleName",
          "type": "string"
        },
        {
          "internalType": "uint256",
          "name": "contributionAmount",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "tokenAddress",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "isNativeToken",
          "type": "bool"
        }
      ],
      "name": "createROSCA",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "circleId",
          "type": "address"
        },
        {
          "internalType": "string",
          "name": "circleName",
          "type": "string"
        },
        {
          "internalType": "address",
          "name": "tokenAddress",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "isNativeToken",
          "type": "bool"
        }
      ],
      "name": "createSavingsPool",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "donationImplementation",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getAllPools",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "",
          "type": "address[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "circleId",
          "type": "address"
        }
      ],
      "name": "getCirclePool",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "poolAddress",
          "type": "address"
        }
      ],
      "name": "getPoolType",
      "outputs": [
        {
          "internalType": "enum XershaFactory.PoolType",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getTotalPools",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "isValidPool",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "poolTypes",
      "outputs": [
        {
          "internalType": "enum XershaFactory.PoolType",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "roscaImplementation",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "savingsImplementation",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newImplementation",
          "type": "address"
        }
      ],
      "name": "setDonationImplementation",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_roscaImpl",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_savingsImpl",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_donationImpl",
          "type": "address"
        }
      ],
      "name": "setImplementations",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newImplementation",
          "type": "address"
        }
      ],
      "name": "setROSCAImplementation",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newImplementation",
          "type": "address"
        }
      ],
      "name": "setSavingsImplementation",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xf40e2622fe7e13b824a2f13932f850a21b03ef55520796eb5d69af4b2e73b455",
  "receipt": {
    "to": null,
    "from": "0x8244c1645C1a7890Ef1F0E79AcCf817905Dbcba2",
    "contractAddress": "0x2b3Bf926948E5ff1742239130028Bdb6FD2B4614",
    "transactionIndex": 6,
    "gasUsed": "1240072",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000220000000000000000000800000000000000000000000000000000400000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000001000000000000000020000000000000000000800000000000000000000000000000000000000000000000",
    "blockHash": "0xe284d32566df45513024a75700e4f3bf3ee3b9fa436b3787476a037dbdbbb32b",
    "transactionHash": "0xf40e2622fe7e13b824a2f13932f850a21b03ef55520796eb5d69af4b2e73b455",
    "logs": [
      {
        "transactionIndex": 6,
        "blockNumber": 17211660,
        "transactionHash": "0xf40e2622fe7e13b824a2f13932f850a21b03ef55520796eb5d69af4b2e73b455",
        "address": "0x2b3Bf926948E5ff1742239130028Bdb6FD2B4614",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000008244c1645c1a7890ef1f0e79accf817905dbcba2"
        ],
        "data": "0x",
        "logIndex": 22,
        "blockHash": "0xe284d32566df45513024a75700e4f3bf3ee3b9fa436b3787476a037dbdbbb32b"
      }
    ],
    "blockNumber": 17211660,
    "cumulativeGasUsed": "2427002",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x8244c1645C1a7890Ef1F0E79AcCf817905Dbcba2",
    "0xB86F87384442d9fAE87769c46126fAe912dB5632",
    "0x05E6C6eb7A257A15b37b6cC3787121014B71E299",
    "0x4E0469c34ba2EC35fAD096e730efCB6293c96608"
  ],
  "numDeployments": 2,
  "solcInputHash": "5826f86a7677600ec4f6d996ce30862e",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initialOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_roscaImpl\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_savingsImpl\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_donationImpl\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ERC1167FailedCreateClone\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"poolType\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"ImplementationUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"circleId\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum XershaFactory.PoolType\",\"name\":\"poolType\",\"type\":\"uint8\"}],\"name\":\"PoolCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allPools\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"circleToPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"circleId\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"circleName\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"goalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isNativeToken\",\"type\":\"bool\"}],\"name\":\"createDonationPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"circleId\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"circleName\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"contributionAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isNativeToken\",\"type\":\"bool\"}],\"name\":\"createROSCA\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"circleId\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"circleName\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isNativeToken\",\"type\":\"bool\"}],\"name\":\"createSavingsPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"donationImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllPools\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"circleId\",\"type\":\"address\"}],\"name\":\"getCirclePool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"}],\"name\":\"getPoolType\",\"outputs\":[{\"internalType\":\"enum XershaFactory.PoolType\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalPools\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isValidPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"poolTypes\",\"outputs\":[{\"internalType\":\"enum XershaFactory.PoolType\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"roscaImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"savingsImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"setDonationImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_roscaImpl\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_savingsImpl\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_donationImpl\",\"type\":\"address\"}],\"name\":\"setImplementations\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"setROSCAImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"setSavingsImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Enforces one pool per circle and tracks all deployed pools      Uses EIP-1167 minimal proxies (clones) for gas-efficient pool deployment\",\"errors\":{\"ERC1167FailedCreateClone()\":[{\"details\":\"A clone instance deployment failed.\"}],\"OwnableInvalidOwner(address)\":[{\"details\":\"The owner is not a valid owner account. (eg. `address(0)`)\"}],\"OwnableUnauthorizedAccount(address)\":[{\"details\":\"The caller account is not authorized to perform an operation.\"}]},\"events\":{\"ImplementationUpdated(string,address)\":{\"params\":{\"newImplementation\":\"The new implementation address\",\"poolType\":\"The type of pool implementation that was updated\"}},\"PoolCreated(address,address,address,uint8)\":{\"params\":{\"circleId\":\"The Lens.xyz circle contract address\",\"creator\":\"The address that created the pool\",\"poolAddress\":\"The address of the newly created pool\",\"poolType\":\"The type of pool created (ROSCA, SAVINGS, or DONATION)\"}}},\"kind\":\"dev\",\"methods\":{\"constructor\":{\"params\":{\"_donationImpl\":\"Address of the Donation pool implementation\",\"_roscaImpl\":\"Address of the ROSCA pool implementation\",\"_savingsImpl\":\"Address of the Savings pool implementation\",\"initialOwner\":\"Address that will own the factory\"}},\"createDonationPool(address,string,address,uint256,uint256,address,bool)\":{\"details\":\"Validates circle ID and ensures no duplicate pools for the same circle      Uses EIP-1167 minimal proxy pattern for gas-efficient deployment\",\"params\":{\"beneficiary\":\"The address that will receive the donated funds\",\"circleId\":\"The Lens.xyz circle contract address\",\"circleName\":\"The name of the circle\",\"deadline\":\"Unix timestamp when fundraising ends\",\"goalAmount\":\"The fundraising goal amount in wei\",\"isNativeToken\":\"Whether to use native token or ERC20\",\"tokenAddress\":\"Address of the ERC20 token (zero address if native)\"},\"returns\":{\"_0\":\"The address of the newly created Donation pool clone\"}},\"createROSCA(address,string,uint256,address,bool)\":{\"details\":\"Validates circle ID and ensures no duplicate pools for the same circle      Uses EIP-1167 minimal proxy pattern for gas-efficient deployment\",\"params\":{\"circleId\":\"The Lens.xyz circle contract address\",\"circleName\":\"The name of the circle\",\"contributionAmount\":\"Fixed amount each member must contribute per round\",\"isNativeToken\":\"Whether to use native token or ERC20\",\"tokenAddress\":\"Address of the ERC20 token (zero address if native)\"},\"returns\":{\"_0\":\"The address of the newly created ROSCA pool clone\"}},\"createSavingsPool(address,string,address,bool)\":{\"details\":\"Validates circle ID and ensures no duplicate pools for the same circle      Uses EIP-1167 minimal proxy pattern for gas-efficient deployment\",\"params\":{\"circleId\":\"The Lens.xyz circle contract address\",\"circleName\":\"The name of the circle\",\"isNativeToken\":\"Whether to use native token or ERC20\",\"tokenAddress\":\"Address of the ERC20 token (zero address if native)\"},\"returns\":{\"_0\":\"The address of the newly created Savings pool clone\"}},\"getAllPools()\":{\"details\":\"Warning: This can be gas-intensive for large numbers of pools\",\"returns\":{\"_0\":\"Array of all pool addresses\"}},\"getCirclePool(address)\":{\"params\":{\"circleId\":\"The circle contract address\"},\"returns\":{\"_0\":\"The pool address, or zero address if no pool exists\"}},\"getPoolType(address)\":{\"params\":{\"poolAddress\":\"The pool address to query\"},\"returns\":{\"_0\":\"The PoolType enum value\"}},\"getTotalPools()\":{\"returns\":{\"_0\":\"The total pool count\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"setDonationImplementation(address)\":{\"details\":\"Only owner can update. New pools will use the new implementation\",\"params\":{\"newImplementation\":\"Address of the new Donation implementation\"}},\"setImplementations(address,address,address)\":{\"details\":\"Only owner can update. Pass address(0) to skip updating a specific implementation\",\"params\":{\"_donationImpl\":\"New Donation implementation (or address(0) to skip)\",\"_roscaImpl\":\"New ROSCA implementation (or address(0) to skip)\",\"_savingsImpl\":\"New Savings implementation (or address(0) to skip)\"}},\"setROSCAImplementation(address)\":{\"details\":\"Only owner can update. New pools will use the new implementation\",\"params\":{\"newImplementation\":\"Address of the new ROSCA implementation\"}},\"setSavingsImplementation(address)\":{\"details\":\"Only owner can update. New pools will use the new implementation\",\"params\":{\"newImplementation\":\"Address of the new Savings implementation\"}},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"title\":\"XershaFactory\",\"version\":1},\"userdoc\":{\"events\":{\"ImplementationUpdated(string,address)\":{\"notice\":\"Emitted when an implementation address is updated\"},\"PoolCreated(address,address,address,uint8)\":{\"notice\":\"Emitted when a new pool is created\"}},\"kind\":\"user\",\"methods\":{\"allPools(uint256)\":{\"notice\":\"Array of all pools created by this factory\"},\"circleToPool(address)\":{\"notice\":\"Mapping from circle contract address to pool address\"},\"constructor\":{\"notice\":\"Initializes the factory with implementation addresses\"},\"createDonationPool(address,string,address,uint256,uint256,address,bool)\":{\"notice\":\"Creates a new Donation pool for group fundraising\"},\"createROSCA(address,string,uint256,address,bool)\":{\"notice\":\"Creates a new ROSCA (Rotating Savings and Credit Association) pool\"},\"createSavingsPool(address,string,address,bool)\":{\"notice\":\"Creates a new Savings pool for collective savings\"},\"donationImplementation()\":{\"notice\":\"Implementation contract for Donation pools\"},\"getAllPools()\":{\"notice\":\"Gets all pool addresses created by this factory\"},\"getCirclePool(address)\":{\"notice\":\"Gets the pool address for a given circle\"},\"getPoolType(address)\":{\"notice\":\"Gets the pool type for a given pool address\"},\"getTotalPools()\":{\"notice\":\"Gets the total number of pools created by this factory\"},\"isValidPool(address)\":{\"notice\":\"Mapping to validate if an address is a legitimate pool created by this factory\"},\"poolTypes(address)\":{\"notice\":\"Mapping from pool address to pool type\"},\"roscaImplementation()\":{\"notice\":\"Implementation contract for ROSCA pools\"},\"savingsImplementation()\":{\"notice\":\"Implementation contract for Savings pools\"},\"setDonationImplementation(address)\":{\"notice\":\"Updates the Donation pool implementation address\"},\"setImplementations(address,address,address)\":{\"notice\":\"Updates all implementation addresses at once\"},\"setROSCAImplementation(address)\":{\"notice\":\"Updates the ROSCA pool implementation address\"},\"setSavingsImplementation(address)\":{\"notice\":\"Updates the Savings pool implementation address\"}},\"notice\":\"Factory contract for creating and managing Xersha pools using minimal proxy pattern\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/XershaFactory.sol\":\"XershaFactory\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xff6d0bb2e285473e5311d9d3caacb525ae3538a80758c10649a4d61029b017bb\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/Clones.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Clones.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n */\\nlibrary Clones {\\n    /**\\n     * @dev A clone instance deployment failed.\\n     */\\n    error ERC1167FailedCreateClone();\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create(0, 0x09, 0x37)\\n        }\\n        if (instance == address(0)) {\\n            revert ERC1167FailedCreateClone();\\n        }\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create2(0, 0x09, 0x37, salt)\\n        }\\n        if (instance == address(0)) {\\n            revert ERC1167FailedCreateClone();\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(add(ptr, 0x38), deployer)\\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\\n            mstore(add(ptr, 0x14), implementation)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\\n            mstore(add(ptr, 0x58), salt)\\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\\n            predicted := keccak256(add(ptr, 0x43), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt\\n    ) internal view returns (address predicted) {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\",\"keccak256\":\"0xd18408af8a91bedb3d56343eeb9b30eb852e6dea93a5e2d5c6db9ca4cb905155\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\",\"keccak256\":\"0xc6a8ff0ea489379b61faa647490411b80102578440ab9d84e9a957cc12164e70\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0x493033a8d1b176a037b2cc6a04dad01a5c157722049bbecf632ca876224dd4b2\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Pausable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    bool private _paused;\\n\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    /**\\n     * @dev The operation failed because the contract is paused.\\n     */\\n    error EnforcedPause();\\n\\n    /**\\n     * @dev The operation failed because the contract is not paused.\\n     */\\n    error ExpectedPause();\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        if (paused()) {\\n            revert EnforcedPause();\\n        }\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        if (!paused()) {\\n            revert ExpectedPause();\\n        }\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\",\"keccak256\":\"0xb2e5f50762c27fb4b123e3619c3c02bdcba5e515309382e5bfb6f7d6486510bd\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant NOT_ENTERED = 1;\\n    uint256 private constant ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    /**\\n     * @dev Unauthorized reentrant call.\\n     */\\n    error ReentrancyGuardReentrantCall();\\n\\n    constructor() {\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\n        if (_status == ENTERED) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == ENTERED;\\n    }\\n}\\n\",\"keccak256\":\"0xf980daa263b661ab8ddee7d4fd833c7da7e7995e2c359ff1f17e67e4112f2236\",\"license\":\"MIT\"},\"contracts/XershaFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/proxy/Clones.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./pools/ROSCAPool.sol\\\";\\nimport \\\"./pools/SavingsPool.sol\\\";\\nimport \\\"./pools/DonationPool.sol\\\";\\n\\n/**\\n * @title XershaFactory\\n * @notice Factory contract for creating and managing Xersha pools using minimal proxy pattern\\n * @dev Enforces one pool per circle and tracks all deployed pools\\n *      Uses EIP-1167 minimal proxies (clones) for gas-efficient pool deployment\\n */\\ncontract XershaFactory is Ownable {\\n    // ========== Types ==========\\n\\n    enum PoolType {\\n        ROSCA,\\n        SAVINGS,\\n        DONATION\\n    }\\n\\n    // ========== State Variables ==========\\n\\n    /// @notice Implementation contract for ROSCA pools\\n    address public roscaImplementation;\\n\\n    /// @notice Implementation contract for Savings pools\\n    address public savingsImplementation;\\n\\n    /// @notice Implementation contract for Donation pools\\n    address public donationImplementation;\\n\\n    /// @notice Mapping from circle contract address to pool address\\n    mapping(address => address) public circleToPool;\\n\\n    /// @notice Mapping to validate if an address is a legitimate pool created by this factory\\n    mapping(address => bool) public isValidPool;\\n\\n    /// @notice Mapping from pool address to pool type\\n    mapping(address => PoolType) public poolTypes;\\n\\n    /// @notice Array of all pools created by this factory\\n    address[] public allPools;\\n\\n    // ========== Events ==========\\n\\n    /**\\n     * @notice Emitted when a new pool is created\\n     * @param circleId The Lens.xyz circle contract address\\n     * @param poolAddress The address of the newly created pool\\n     * @param creator The address that created the pool\\n     * @param poolType The type of pool created (ROSCA, SAVINGS, or DONATION)\\n     */\\n    event PoolCreated(\\n        address indexed circleId,\\n        address indexed poolAddress,\\n        address indexed creator,\\n        PoolType poolType\\n    );\\n\\n    /**\\n     * @notice Emitted when an implementation address is updated\\n     * @param poolType The type of pool implementation that was updated\\n     * @param newImplementation The new implementation address\\n     */\\n    event ImplementationUpdated(string poolType, address indexed newImplementation);\\n\\n    // ========== Constructor ==========\\n\\n    /**\\n     * @notice Initializes the factory with implementation addresses\\n     * @param initialOwner Address that will own the factory\\n     * @param _roscaImpl Address of the ROSCA pool implementation\\n     * @param _savingsImpl Address of the Savings pool implementation\\n     * @param _donationImpl Address of the Donation pool implementation\\n     */\\n    constructor(\\n        address initialOwner,\\n        address _roscaImpl,\\n        address _savingsImpl,\\n        address _donationImpl\\n    ) Ownable(initialOwner) {\\n        require(_roscaImpl != address(0), \\\"Invalid ROSCA implementation\\\");\\n        require(_savingsImpl != address(0), \\\"Invalid Savings implementation\\\");\\n        require(_donationImpl != address(0), \\\"Invalid Donation implementation\\\");\\n\\n        roscaImplementation = _roscaImpl;\\n        savingsImplementation = _savingsImpl;\\n        donationImplementation = _donationImpl;\\n    }\\n\\n    // ========== Pool Creation Functions ==========\\n\\n    /**\\n     * @notice Creates a new ROSCA (Rotating Savings and Credit Association) pool\\n     * @dev Validates circle ID and ensures no duplicate pools for the same circle\\n     *      Uses EIP-1167 minimal proxy pattern for gas-efficient deployment\\n     * @param circleId The Lens.xyz circle contract address\\n     * @param circleName The name of the circle\\n     * @param contributionAmount Fixed amount each member must contribute per round\\n     * @param tokenAddress Address of the ERC20 token (zero address if native)\\n     * @param isNativeToken Whether to use native token or ERC20\\n     * @return The address of the newly created ROSCA pool clone\\n     */\\n    function createROSCA(\\n        address circleId,\\n        string memory circleName,\\n        uint256 contributionAmount,\\n        address tokenAddress,\\n        bool isNativeToken\\n    ) external returns (address) {\\n        _validateCircleId(circleId);\\n        require(circleToPool[circleId] == address(0), \\\"Circle already has pool\\\");\\n        require(contributionAmount > 0, \\\"Invalid contribution amount\\\");\\n\\n        // Clone the ROSCA implementation\\n        address clone = Clones.clone(roscaImplementation);\\n\\n        // Initialize the clone\\n        ROSCAPool(clone).initialize(\\n            msg.sender,\\n            circleId,\\n            circleName,\\n            contributionAmount,\\n            tokenAddress,\\n            isNativeToken\\n        );\\n\\n        _registerPool(circleId, clone, PoolType.ROSCA);\\n\\n        emit PoolCreated(circleId, clone, msg.sender, PoolType.ROSCA);\\n        return clone;\\n    }\\n\\n    /**\\n     * @notice Creates a new Savings pool for collective savings\\n     * @dev Validates circle ID and ensures no duplicate pools for the same circle\\n     *      Uses EIP-1167 minimal proxy pattern for gas-efficient deployment\\n     * @param circleId The Lens.xyz circle contract address\\n     * @param circleName The name of the circle\\n     * @param tokenAddress Address of the ERC20 token (zero address if native)\\n     * @param isNativeToken Whether to use native token or ERC20\\n     * @return The address of the newly created Savings pool clone\\n     */\\n    function createSavingsPool(\\n        address circleId,\\n        string memory circleName,\\n        address tokenAddress,\\n        bool isNativeToken\\n    ) external returns (address) {\\n        _validateCircleId(circleId);\\n        require(circleToPool[circleId] == address(0), \\\"Circle already has pool\\\");\\n\\n        // Clone the Savings implementation\\n        address clone = Clones.clone(savingsImplementation);\\n\\n        // Initialize the clone\\n        SavingsPool(clone).initialize(\\n            msg.sender,\\n            circleId,\\n            circleName,\\n            tokenAddress,\\n            isNativeToken\\n        );\\n\\n        _registerPool(circleId, clone, PoolType.SAVINGS);\\n\\n        emit PoolCreated(circleId, clone, msg.sender, PoolType.SAVINGS);\\n        return clone;\\n    }\\n\\n    /**\\n     * @notice Creates a new Donation pool for group fundraising\\n     * @dev Validates circle ID and ensures no duplicate pools for the same circle\\n     *      Uses EIP-1167 minimal proxy pattern for gas-efficient deployment\\n     * @param circleId The Lens.xyz circle contract address\\n     * @param circleName The name of the circle\\n     * @param beneficiary The address that will receive the donated funds\\n     * @param goalAmount The fundraising goal amount in wei\\n     * @param deadline Unix timestamp when fundraising ends\\n     * @param tokenAddress Address of the ERC20 token (zero address if native)\\n     * @param isNativeToken Whether to use native token or ERC20\\n     * @return The address of the newly created Donation pool clone\\n     */\\n    function createDonationPool(\\n        address circleId,\\n        string memory circleName,\\n        address beneficiary,\\n        uint256 goalAmount,\\n        uint256 deadline,\\n        address tokenAddress,\\n        bool isNativeToken\\n    ) external returns (address) {\\n        _validateCircleId(circleId);\\n        require(circleToPool[circleId] == address(0), \\\"Circle already has pool\\\");\\n        require(beneficiary != address(0), \\\"Invalid beneficiary\\\");\\n        require(goalAmount > 0, \\\"Invalid goal\\\");\\n        require(deadline > block.timestamp, \\\"Invalid deadline\\\");\\n\\n        // Clone the Donation implementation\\n        address clone = Clones.clone(donationImplementation);\\n\\n        // Initialize the clone\\n        DonationPool(clone).initialize(\\n            msg.sender,\\n            circleId,\\n            circleName,\\n            beneficiary,\\n            goalAmount,\\n            deadline,\\n            tokenAddress,\\n            isNativeToken\\n        );\\n\\n        _registerPool(circleId, clone, PoolType.DONATION);\\n\\n        emit PoolCreated(circleId, clone, msg.sender, PoolType.DONATION);\\n        return clone;\\n    }\\n\\n    // ========== Admin Functions ==========\\n\\n    /**\\n     * @notice Updates the ROSCA pool implementation address\\n     * @dev Only owner can update. New pools will use the new implementation\\n     * @param newImplementation Address of the new ROSCA implementation\\n     */\\n    function setROSCAImplementation(address newImplementation) external onlyOwner {\\n        require(newImplementation != address(0), \\\"Invalid implementation\\\");\\n        roscaImplementation = newImplementation;\\n        emit ImplementationUpdated(\\\"ROSCA\\\", newImplementation);\\n    }\\n\\n    /**\\n     * @notice Updates the Savings pool implementation address\\n     * @dev Only owner can update. New pools will use the new implementation\\n     * @param newImplementation Address of the new Savings implementation\\n     */\\n    function setSavingsImplementation(address newImplementation) external onlyOwner {\\n        require(newImplementation != address(0), \\\"Invalid implementation\\\");\\n        savingsImplementation = newImplementation;\\n        emit ImplementationUpdated(\\\"SAVINGS\\\", newImplementation);\\n    }\\n\\n    /**\\n     * @notice Updates the Donation pool implementation address\\n     * @dev Only owner can update. New pools will use the new implementation\\n     * @param newImplementation Address of the new Donation implementation\\n     */\\n    function setDonationImplementation(address newImplementation) external onlyOwner {\\n        require(newImplementation != address(0), \\\"Invalid implementation\\\");\\n        donationImplementation = newImplementation;\\n        emit ImplementationUpdated(\\\"DONATION\\\", newImplementation);\\n    }\\n\\n    /**\\n     * @notice Updates all implementation addresses at once\\n     * @dev Only owner can update. Pass address(0) to skip updating a specific implementation\\n     * @param _roscaImpl New ROSCA implementation (or address(0) to skip)\\n     * @param _savingsImpl New Savings implementation (or address(0) to skip)\\n     * @param _donationImpl New Donation implementation (or address(0) to skip)\\n     */\\n    function setImplementations(\\n        address _roscaImpl,\\n        address _savingsImpl,\\n        address _donationImpl\\n    ) external onlyOwner {\\n        if (_roscaImpl != address(0)) {\\n            roscaImplementation = _roscaImpl;\\n            emit ImplementationUpdated(\\\"ROSCA\\\", _roscaImpl);\\n        }\\n        if (_savingsImpl != address(0)) {\\n            savingsImplementation = _savingsImpl;\\n            emit ImplementationUpdated(\\\"SAVINGS\\\", _savingsImpl);\\n        }\\n        if (_donationImpl != address(0)) {\\n            donationImplementation = _donationImpl;\\n            emit ImplementationUpdated(\\\"DONATION\\\", _donationImpl);\\n        }\\n    }\\n\\n    // ========== Internal Functions ==========\\n\\n    /**\\n     * @notice Validates that the circle ID is not the zero address\\n     * @dev Circle IDs can reference contracts on other chains (e.g., Lens circles on Polygon)\\n     * @param circleId The circle address to validate\\n     */\\n    function _validateCircleId(address circleId) private pure {\\n        require(circleId != address(0), \\\"Zero address not allowed\\\");\\n    }\\n\\n    /**\\n     * @notice Registers a newly created pool in the factory's tracking systems\\n     * @param circleId The circle contract address\\n     * @param poolAddress The address of the newly created pool\\n     * @param poolType The type of pool (ROSCA, SAVINGS, or DONATION)\\n     */\\n    function _registerPool(address circleId, address poolAddress, PoolType poolType) private {\\n        circleToPool[circleId] = poolAddress;\\n        isValidPool[poolAddress] = true;\\n        poolTypes[poolAddress] = poolType;\\n        allPools.push(poolAddress);\\n    }\\n\\n    // ========== View Functions ==========\\n\\n    /**\\n     * @notice Gets the pool address for a given circle\\n     * @param circleId The circle contract address\\n     * @return The pool address, or zero address if no pool exists\\n     */\\n    function getCirclePool(address circleId) external view returns (address) {\\n        return circleToPool[circleId];\\n    }\\n\\n    /**\\n     * @notice Gets the total number of pools created by this factory\\n     * @return The total pool count\\n     */\\n    function getTotalPools() external view returns (uint256) {\\n        return allPools.length;\\n    }\\n\\n    /**\\n     * @notice Gets all pool addresses created by this factory\\n     * @dev Warning: This can be gas-intensive for large numbers of pools\\n     * @return Array of all pool addresses\\n     */\\n    function getAllPools() external view returns (address[] memory) {\\n        return allPools;\\n    }\\n\\n    /**\\n     * @notice Gets the pool type for a given pool address\\n     * @param poolAddress The pool address to query\\n     * @return The PoolType enum value\\n     */\\n    function getPoolType(address poolAddress) external view returns (PoolType) {\\n        require(isValidPool[poolAddress], \\\"Invalid pool address\\\");\\n        return poolTypes[poolAddress];\\n    }\\n}\\n\",\"keccak256\":\"0xaa89271f7add988b0e7e2c86a2a45462ed68005e64f4b3968fbf27b7942130b9\",\"license\":\"MIT\"},\"contracts/interfaces/IXershaPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title IXershaPool\\n * @notice Base interface for all Xersha pool types\\n * @dev Common interface elements shared across ROSCA, Savings, and Donation pools\\n */\\ninterface IXershaPool {\\n    /**\\n     * @notice Returns the address of the circle (Lens.xyz contract) this pool belongs to\\n     * @return The circle contract address\\n     */\\n    function circleId() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address of the user who created this pool\\n     * @return The creator's address\\n     */\\n    function creator() external view returns (address);\\n\\n    /**\\n     * @notice Returns the human-readable name of the circle\\n     * @return The circle name\\n     */\\n    function circleName() external view returns (string memory);\\n\\n    /**\\n     * @notice Returns whether the pool is currently active\\n     * @return True if pool is active, false otherwise\\n     */\\n    function isActive() external view returns (bool);\\n\\n    /**\\n     * @notice Returns the list of all members in the pool\\n     * @return Array of member addresses\\n     */\\n    function getMembers() external view returns (address[] memory);\\n\\n    /**\\n     * @notice Returns the total number of members in the pool\\n     * @return Member count\\n     */\\n    function getMemberCount() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xd2c7c0badc538eded859db0878717a051e963062f67e0130fa55168c5d898c9f\",\"license\":\"MIT\"},\"contracts/libraries/TokenTransfer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @title TokenTransfer\\n * @notice Library for handling both native token and ERC20 token transfers\\n * @dev Reduces code duplication across pool contracts\\n */\\nlibrary TokenTransfer {\\n    /**\\n     * @notice Receives tokens from sender (either native or ERC20)\\n     * @param tokenAddress Address of the ERC20 token (zero address if native)\\n     * @param isNativeToken Whether this is a native token transfer\\n     * @param amount Amount of tokens to receive (for ERC20) or 0 (for native)\\n     * @return The actual amount received\\n     */\\n    function receiveTokens(\\n        address tokenAddress,\\n        bool isNativeToken,\\n        uint256 amount\\n    ) internal returns (uint256) {\\n        if (isNativeToken) {\\n            require(msg.value > 0, \\\"Must send native token\\\");\\n            return msg.value;\\n        } else {\\n            require(msg.value == 0, \\\"No native token\\\");\\n            IERC20(tokenAddress).transferFrom(msg.sender, address(this), amount);\\n            return amount;\\n        }\\n    }\\n\\n    /**\\n     * @notice Sends tokens to recipient (either native or ERC20)\\n     * @param tokenAddress Address of the ERC20 token (zero address if native)\\n     * @param isNativeToken Whether this is a native token transfer\\n     * @param recipient Address to send tokens to\\n     * @param amount Amount of tokens to send\\n     */\\n    function sendTokens(\\n        address tokenAddress,\\n        bool isNativeToken,\\n        address recipient,\\n        uint256 amount\\n    ) internal {\\n        if (isNativeToken) {\\n            (bool success, ) = payable(recipient).call{value: amount}(\\\"\\\");\\n            require(success, \\\"Transfer failed\\\");\\n        } else {\\n            IERC20(tokenAddress).transfer(recipient, amount);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8c116fcbb351414ae623d0b922a11014c69284a82783f7b97ddfbbc41c755094\",\"license\":\"MIT\"},\"contracts/pools/DonationPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Pausable.sol\\\";\\nimport \\\"../interfaces/IXershaPool.sol\\\";\\nimport \\\"../libraries/TokenTransfer.sol\\\";\\n\\n/**\\n * @title DonationPool\\n * @notice Fundraising pool where circle members donate toward a specific goal and beneficiary\\n * @dev Includes refund mechanism if goal is not met by deadline\\n */\\ncontract DonationPool is IXershaPool, ReentrancyGuard, Pausable {\\n    using TokenTransfer for address;\\n\\n    // ========== State Variables ==========\\n\\n    /// @notice Address of the user who created this pool\\n    address public creator;\\n\\n    /// @notice Address of the Lens.xyz circle contract\\n    address public circleId;\\n\\n    /// @notice Human-readable name of the circle\\n    string public circleName;\\n\\n    /// @notice Address of the ERC20 token used for donations (zero address if native token)\\n    address public tokenAddress;\\n\\n    /// @notice Whether this pool uses native token (cBTC) or ERC20 token\\n    bool public isNativeToken;\\n\\n    /// @notice Address that will receive the donated funds\\n    address public beneficiary;\\n\\n    /// @notice Target fundraising amount in wei\\n    uint256 public goalAmount;\\n\\n    /// @notice Deadline for fundraising as Unix timestamp\\n    uint256 public deadline;\\n\\n    /// @notice Total amount raised so far\\n    uint256 public totalRaised;\\n\\n    /// @notice Individual donation amounts per member\\n    mapping(address => uint256) public donations;\\n\\n    /// @notice Array of all members in the pool\\n    address[] public members;\\n\\n    /// @notice Mapping to check if an address is a member\\n    mapping(address => bool) public isMember;\\n\\n    /// @notice Mapping to check if an address has been invited\\n    mapping(address => bool) public isInvited;\\n\\n    /// @notice Array of addresses that have donated\\n    address[] public donors;\\n\\n    /// @notice Whether funds have been released to beneficiary\\n    bool public fundsReleased;\\n\\n    /// @notice Whether the pool is currently active\\n    bool public isActive;\\n\\n    /// @notice Whether refunds are enabled (goal not met by deadline)\\n    bool public refundsEnabled;\\n\\n    /// @notice Whether this contract has been initialized (for clone pattern)\\n    bool private initialized;\\n\\n    // ========== Events ==========\\n\\n    event PoolCreated(\\n        address indexed circleId,\\n        address indexed creator,\\n        address beneficiary,\\n        uint256 goal,\\n        uint256 deadline\\n    );\\n    event MemberInvited(address indexed member, address indexed invitedBy);\\n    event MemberJoined(address indexed member);\\n    event DonationMade(address indexed donor, uint256 amount);\\n    event GoalReached(uint256 totalRaised);\\n    event FundsReleased(address indexed beneficiary, uint256 amount);\\n    event RefundsEnabled(uint256 timestamp);\\n    event RefundClaimed(address indexed donor, uint256 amount);\\n\\n    // ========== Modifiers ==========\\n\\n    modifier onlyCreator() {\\n        require(msg.sender == creator, \\\"Only creator can call this\\\");\\n        _;\\n    }\\n\\n    modifier onlyMember() {\\n        require(isMember[msg.sender], \\\"Not a member\\\");\\n        _;\\n    }\\n\\n    modifier onlyInvited() {\\n        require(isInvited[msg.sender], \\\"Not invited\\\");\\n        _;\\n    }\\n\\n    // ========== Constructor ==========\\n\\n    /**\\n     * @notice Constructor for implementation contract\\n     * @dev Prevents the implementation contract from being initialized\\n     */\\n    constructor() {\\n        initialized = true;\\n    }\\n\\n    /**\\n     * @notice Initializes a new Donation pool clone\\n     * @dev This replaces the constructor for cloned instances\\n     * @param _creator Address of the user creating the pool\\n     * @param _circleId Address of the Lens.xyz circle contract\\n     * @param _circleName Name of the circle\\n     * @param _beneficiary Address that will receive the funds\\n     * @param _goalAmount Target fundraising amount in wei\\n     * @param _deadline Deadline as Unix timestamp\\n     * @param _tokenAddress Address of the ERC20 token to use for donations (zero address if native)\\n     * @param _isNativeToken Whether this pool uses native token (cBTC) or ERC20 token\\n     */\\n    function initialize(\\n        address _creator,\\n        address _circleId,\\n        string memory _circleName,\\n        address _beneficiary,\\n        uint256 _goalAmount,\\n        uint256 _deadline,\\n        address _tokenAddress,\\n        bool _isNativeToken\\n    ) external {\\n        require(!initialized, \\\"Already initialized\\\");\\n        initialized = true;\\n\\n        require(_beneficiary != address(0), \\\"Invalid beneficiary\\\");\\n        require(_goalAmount > 0, \\\"Goal must be positive\\\");\\n        require(_deadline > block.timestamp, \\\"Deadline must be future\\\");\\n\\n        // Validate token address based on token type\\n        if (_isNativeToken) {\\n            require(_tokenAddress == address(0), \\\"Token address must be zero for native token\\\");\\n        } else {\\n            require(_tokenAddress != address(0), \\\"Invalid token address for ERC20\\\");\\n        }\\n\\n        creator = _creator;\\n        circleId = _circleId;\\n        circleName = _circleName;\\n        beneficiary = _beneficiary;\\n        goalAmount = _goalAmount;\\n        deadline = _deadline;\\n        tokenAddress = _tokenAddress;\\n        isNativeToken = _isNativeToken;\\n        isActive = true;\\n\\n        // Creator automatically becomes a member\\n        members.push(_creator);\\n        isMember[_creator] = true;\\n        isInvited[_creator] = true;\\n\\n        emit PoolCreated(_circleId, _creator, _beneficiary, _goalAmount, _deadline);\\n        emit MemberJoined(_creator);\\n    }\\n\\n    // ========== Member Management ==========\\n\\n    /**\\n     * @notice Invites a new member to the pool\\n     * @dev Only creator can invite members\\n     * @param member Address of the member to invite\\n     */\\n    function inviteMember(address member) external onlyCreator whenNotPaused {\\n        require(!isInvited[member], \\\"Already invited\\\");\\n        require(member != address(0), \\\"Invalid address\\\");\\n\\n        isInvited[member] = true;\\n        emit MemberInvited(member, creator);\\n    }\\n\\n    /**\\n     * @notice Allows an invited member to join the pool\\n     */\\n    function joinPool() external onlyInvited whenNotPaused {\\n        require(!isMember[msg.sender], \\\"Already a member\\\");\\n\\n        members.push(msg.sender);\\n        isMember[msg.sender] = true;\\n\\n        emit MemberJoined(msg.sender);\\n    }\\n\\n    // ========== Donations ==========\\n\\n    /**\\n     * @notice Allows a member to donate to the pool\\n     * @dev For ERC20: Member must have approved the contract to spend tokens before calling\\n     *      For native token: amount parameter is ignored, msg.value is used\\n     * @param amount Amount of ERC20 tokens to donate (ignored for native token pools)\\n     */\\n    function donate(uint256 amount) external payable onlyMember whenNotPaused nonReentrant {\\n        require(block.timestamp <= deadline, \\\"Deadline passed\\\");\\n        require(!fundsReleased, \\\"Funds already released\\\");\\n        require(!refundsEnabled, \\\"Refunds enabled, cannot donate\\\");\\n        require(isActive, \\\"Pool not active\\\");\\n        require(isNativeToken || amount > 0, \\\"Must donate something\\\");\\n\\n        uint256 donationAmount = TokenTransfer.receiveTokens(tokenAddress, isNativeToken, amount);\\n\\n        // Track first-time donors\\n        if (donations[msg.sender] == 0) {\\n            donors.push(msg.sender);\\n        }\\n\\n        donations[msg.sender] += donationAmount;\\n        totalRaised += donationAmount;\\n\\n        emit DonationMade(msg.sender, donationAmount);\\n\\n        // Check if goal reached\\n        if (totalRaised >= goalAmount) {\\n            emit GoalReached(totalRaised);\\n        }\\n    }\\n\\n    // ========== Fund Management ==========\\n\\n    /**\\n     * @notice Releases funds to the beneficiary\\n     * @dev Only creator can release, can only release after goal met or deadline passed\\n     */\\n    function releaseFunds() external onlyCreator whenNotPaused nonReentrant {\\n        require(!fundsReleased, \\\"Already released\\\");\\n        require(!refundsEnabled, \\\"Refunds enabled\\\");\\n        require(\\n            totalRaised >= goalAmount || block.timestamp > deadline,\\n            \\\"Goal not met and deadline not passed\\\"\\n        );\\n\\n        fundsReleased = true;\\n        isActive = false;\\n\\n        uint256 amount = isNativeToken\\n            ? address(this).balance\\n            : IERC20(tokenAddress).balanceOf(address(this));\\n\\n        TokenTransfer.sendTokens(tokenAddress, isNativeToken, beneficiary, amount);\\n\\n        emit FundsReleased(beneficiary, amount);\\n    }\\n\\n    /**\\n     * @notice Enables refunds if goal was not met by deadline\\n     * @dev Only creator can enable refunds, only after deadline if goal not met\\n     */\\n    function enableRefunds() external onlyCreator whenNotPaused {\\n        require(!fundsReleased, \\\"Funds already released\\\");\\n        require(!refundsEnabled, \\\"Refunds already enabled\\\");\\n        require(block.timestamp > deadline, \\\"Deadline not passed\\\");\\n        require(totalRaised < goalAmount, \\\"Goal was met\\\");\\n\\n        refundsEnabled = true;\\n        isActive = false;\\n\\n        emit RefundsEnabled(block.timestamp);\\n    }\\n\\n    /**\\n     * @notice Allows a donor to claim their refund\\n     * @dev Only available if refunds are enabled\\n     */\\n    function claimRefund() external whenNotPaused nonReentrant {\\n        require(refundsEnabled, \\\"Refunds not enabled\\\");\\n        require(donations[msg.sender] > 0, \\\"Nothing to refund\\\");\\n\\n        uint256 amount = donations[msg.sender];\\n        donations[msg.sender] = 0;\\n        totalRaised -= amount;\\n\\n        TokenTransfer.sendTokens(tokenAddress, isNativeToken, msg.sender, amount);\\n\\n        emit RefundClaimed(msg.sender, amount);\\n    }\\n\\n    // ========== Emergency Functions ==========\\n\\n    /**\\n     * @notice Pauses the contract in case of emergency\\n     * @dev Only creator can pause\\n     */\\n    function pause() external onlyCreator {\\n        _pause();\\n    }\\n\\n    /**\\n     * @notice Unpauses the contract\\n     * @dev Only creator can unpause\\n     */\\n    function unpause() external onlyCreator {\\n        _unpause();\\n    }\\n\\n    // ========== View Functions ==========\\n\\n    /**\\n     * @notice Gets a member's total donation amount\\n     * @param donor Address of the donor\\n     * @return Donation amount in wei\\n     */\\n    function getDonation(address donor) external view returns (uint256) {\\n        return donations[donor];\\n    }\\n\\n    /**\\n     * @notice Gets the total number of members\\n     * @return Member count\\n     */\\n    function getMemberCount() external view returns (uint256) {\\n        return members.length;\\n    }\\n\\n    /**\\n     * @notice Gets all members\\n     * @return Array of member addresses\\n     */\\n    function getMembers() external view returns (address[] memory) {\\n        return members;\\n    }\\n\\n    /**\\n     * @notice Gets the total number of donors\\n     * @return Donor count\\n     */\\n    function getDonorCount() external view returns (uint256) {\\n        return donors.length;\\n    }\\n\\n    /**\\n     * @notice Gets all donors\\n     * @return Array of donor addresses\\n     */\\n    function getDonors() external view returns (address[] memory) {\\n        return donors;\\n    }\\n\\n    /**\\n     * @notice Gets the time remaining until deadline\\n     * @return Seconds remaining, or 0 if deadline passed\\n     */\\n    function getTimeRemaining() external view returns (uint256) {\\n        if (block.timestamp >= deadline) {\\n            return 0;\\n        }\\n        return deadline - block.timestamp;\\n    }\\n\\n    /**\\n     * @notice Gets the current fundraising progress\\n     * @return raised Current amount raised\\n     * @return goal Goal amount\\n     */\\n    function getProgress() external view returns (uint256 raised, uint256 goal) {\\n        return (totalRaised, goalAmount);\\n    }\\n\\n    /**\\n     * @notice Checks if the fundraising goal has been reached\\n     * @return True if goal reached, false otherwise\\n     */\\n    function isGoalReached() external view returns (bool) {\\n        return totalRaised >= goalAmount;\\n    }\\n\\n    /**\\n     * @notice Gets the contract's current balance\\n     * @return Balance in wei\\n     */\\n    function getContractBalance() external view returns (uint256) {\\n        return address(this).balance;\\n    }\\n}\\n\",\"keccak256\":\"0x644fba87a261bace82a21e667e45c6a2f997fcf8626f209a1c8a4ceb814bd70c\",\"license\":\"MIT\"},\"contracts/pools/ROSCAPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Pausable.sol\\\";\\nimport \\\"../interfaces/IXershaPool.sol\\\";\\nimport \\\"../libraries/TokenTransfer.sol\\\";\\n\\n/**\\n * @title ROSCAPool\\n * @notice Rotating Savings and Credit Association pool implementation\\n * @dev Members contribute fixed amounts each round, one member receives the pot each round\\n * Payout order is provided off-chain by the creator for fairness and transparency\\n */\\ncontract ROSCAPool is IXershaPool, ReentrancyGuard, Pausable {\\n    using TokenTransfer for address;\\n\\n    // ========== Constants ==========\\n\\n    /// @notice Duration of each cycle/round in seconds (30 days)\\n    uint256 public constant CYCLE_DURATION = 30 days;\\n\\n    /// @notice Minimum number of members required to start a ROSCA\\n    uint8 public constant MIN_MEMBERS = 5;\\n\\n    /// @notice Maximum number of members allowed in a ROSCA\\n    uint8 public constant MAX_MEMBERS = 12;\\n\\n    // ========== State Variables ==========\\n\\n    /// @notice Address of the user who created this pool\\n    address public creator;\\n\\n    /// @notice Address of the Lens.xyz circle contract\\n    address public circleId;\\n\\n    /// @notice Human-readable name of the circle\\n    string public circleName;\\n\\n    /// @notice Address of the ERC20 token used for contributions (zero address if native token)\\n    address public tokenAddress;\\n\\n    /// @notice Whether this pool uses native token (cBTC) or ERC20 token\\n    bool public isNativeToken;\\n\\n    /// @notice Fixed contribution amount per round in wei\\n    uint256 public contributionAmount;\\n\\n    /// @notice Array of all members in the pool\\n    address[] public members;\\n\\n    /// @notice Mapping to check if an address is a member\\n    mapping(address => bool) public isMember;\\n\\n    /// @notice Mapping to check if an address has been invited\\n    mapping(address => bool) public isInvited;\\n\\n    /// @notice Total amount contributed by each member across all rounds\\n    mapping(address => uint256) public totalContributed;\\n\\n    /// @notice Array defining the order in which members receive payouts\\n    address[] public payoutOrder;\\n\\n    /// @notice Current round number (1-indexed)\\n    uint8 public currentRound;\\n\\n    /// @notice Whether the current round's payout has been completed\\n    bool public currentRoundPaidOut;\\n\\n    /// @notice Mapping to track which members have received their payout\\n    mapping(address => bool) public hasReceivedPayout;\\n\\n    /// @notice Tracks whether a member has paid for a specific round\\n    mapping(address => mapping(uint8 => bool)) public hasPaid;\\n\\n    /// @notice Timestamp when the ROSCA was started\\n    uint256 public roscaStartTime;\\n\\n    /// @notice Timestamp when the current round started\\n    uint256 public currentRoundStartTime;\\n\\n    /// @notice Whether the ROSCA is currently active\\n    bool public isActive;\\n\\n    /// @notice Whether the ROSCA has completed all rounds\\n    bool public isComplete;\\n\\n    /// @notice Whether this contract has been initialized (for clone pattern)\\n    bool private initialized;\\n\\n    // ========== Events ==========\\n\\n    event ROSCACreated(address indexed circleId, address indexed creator, uint256 contributionAmount);\\n    event MemberInvited(address indexed member, address indexed invitedBy);\\n    event MemberJoined(address indexed member, uint256 timestamp);\\n    event ROSCAStarted(address[] payoutOrder, uint256 startTime);\\n    event ContributionMade(address indexed member, uint8 round, uint256 amount);\\n    event AllMembersContributed(uint8 round);\\n    event PayoutTriggered(address indexed recipient, uint256 amount, uint8 round);\\n    event RoundStarted(uint8 round, uint256 startTime);\\n    event ROSCACompleted(uint256 completionTime);\\n\\n    // ========== Modifiers ==========\\n\\n    modifier onlyCreator() {\\n        require(msg.sender == creator, \\\"Only creator can call this\\\");\\n        _;\\n    }\\n\\n    modifier onlyMember() {\\n        require(isMember[msg.sender], \\\"Not a member\\\");\\n        _;\\n    }\\n\\n    modifier onlyInvited() {\\n        require(isInvited[msg.sender], \\\"Not invited\\\");\\n        _;\\n    }\\n\\n    modifier poolActive() {\\n        require(isActive && !isComplete, \\\"Pool not active\\\");\\n        _;\\n    }\\n\\n    // ========== Constructor ==========\\n\\n    /**\\n     * @notice Constructor for implementation contract\\n     * @dev Prevents the implementation contract from being initialized\\n     */\\n    constructor() {\\n        initialized = true;\\n    }\\n\\n    /**\\n     * @notice Initializes a new ROSCA pool clone\\n     * @dev This replaces the constructor for cloned instances\\n     * @param _creator Address of the user creating the pool\\n     * @param _circleId Address of the Lens.xyz circle contract\\n     * @param _circleName Name of the circle\\n     * @param _contributionAmount Fixed contribution amount per round\\n     * @param _tokenAddress Address of the ERC20 token to use for contributions (zero address if native)\\n     * @param _isNativeToken Whether this pool uses native token (cBTC) or ERC20 token\\n     */\\n    function initialize(\\n        address _creator,\\n        address _circleId,\\n        string memory _circleName,\\n        uint256 _contributionAmount,\\n        address _tokenAddress,\\n        bool _isNativeToken\\n    ) external {\\n        require(!initialized, \\\"Already initialized\\\");\\n        initialized = true;\\n\\n        require(_contributionAmount > 0, \\\"Invalid contribution amount\\\");\\n\\n        // Validate token address based on token type\\n        if (_isNativeToken) {\\n            require(_tokenAddress == address(0), \\\"Token address must be zero for native token\\\");\\n        } else {\\n            require(_tokenAddress != address(0), \\\"Invalid token address for ERC20\\\");\\n        }\\n\\n        creator = _creator;\\n        circleId = _circleId;\\n        circleName = _circleName;\\n        contributionAmount = _contributionAmount;\\n        tokenAddress = _tokenAddress;\\n        isNativeToken = _isNativeToken;\\n\\n        // Creator automatically becomes a member\\n        members.push(_creator);\\n        isMember[_creator] = true;\\n        isInvited[_creator] = true;\\n\\n        emit ROSCACreated(_circleId, _creator, _contributionAmount);\\n        emit MemberJoined(_creator, block.timestamp);\\n    }\\n\\n    // ========== Member Management ==========\\n\\n    /**\\n     * @notice Invites a new member to the ROSCA\\n     * @dev Only creator can invite, only before ROSCA starts\\n     * @param member Address of the member to invite\\n     */\\n    function inviteMember(address member) external onlyCreator whenNotPaused {\\n        require(!isActive, \\\"Cannot invite after ROSCA starts\\\");\\n        require(!isInvited[member], \\\"Already invited\\\");\\n        require(members.length < MAX_MEMBERS, \\\"Max members reached\\\");\\n\\n        isInvited[member] = true;\\n        emit MemberInvited(member, creator);\\n    }\\n\\n    /**\\n     * @notice Allows an invited member to join the pool\\n     * @dev Can only join before ROSCA starts\\n     */\\n    function joinPool() external onlyInvited whenNotPaused {\\n        require(!isActive, \\\"Cannot join after ROSCA starts\\\");\\n        require(!isMember[msg.sender], \\\"Already a member\\\");\\n\\n        members.push(msg.sender);\\n        isMember[msg.sender] = true;\\n\\n        emit MemberJoined(msg.sender, block.timestamp);\\n    }\\n\\n    // ========== ROSCA Lifecycle ==========\\n\\n    /**\\n     * @notice Starts the ROSCA with a provided payout order\\n     * @dev Only creator can start, requires min members, payout order generated off-chain\\n     * @param _payoutOrder Array of addresses defining payout order (must include all members exactly once)\\n     */\\n    function startROSCA(address[] calldata _payoutOrder) external onlyCreator whenNotPaused {\\n        require(!isActive, \\\"Already started\\\");\\n        require(members.length >= MIN_MEMBERS, \\\"Not enough members\\\");\\n        require(_payoutOrder.length == members.length, \\\"Invalid payout order length\\\");\\n\\n        // Validate payout order contains all members exactly once\\n        _validatePayoutOrder(_payoutOrder);\\n\\n        payoutOrder = _payoutOrder;\\n        isActive = true;\\n        currentRound = 1;\\n        roscaStartTime = block.timestamp;\\n        currentRoundStartTime = block.timestamp;\\n\\n        emit ROSCAStarted(_payoutOrder, block.timestamp);\\n        emit RoundStarted(1, block.timestamp);\\n    }\\n\\n    /**\\n     * @notice Validates that payout order contains all members exactly once\\n     * @param _payoutOrder The payout order array to validate\\n     */\\n    function _validatePayoutOrder(address[] calldata _payoutOrder) private view {\\n        // Validate each member is in the payout order and check for duplicates\\n        for (uint256 i = 0; i < _payoutOrder.length; i++) {\\n            address recipient = _payoutOrder[i];\\n            require(isMember[recipient], \\\"Payout order contains non-member\\\");\\n\\n            // Check for duplicates by using a simple loop (gas-efficient for small arrays)\\n            for (uint256 j = i + 1; j < _payoutOrder.length; j++) {\\n                require(_payoutOrder[i] != _payoutOrder[j], \\\"Duplicate in payout order\\\");\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Allows a member to contribute for the current round\\n     * @dev For ERC20: Member must have approved the contract to spend tokens before calling\\n     *      For native token: Must send exact amount of native currency\\n     */\\n    function contribute() external payable onlyMember poolActive whenNotPaused nonReentrant {\\n        require(!hasPaid[msg.sender][currentRound], \\\"Already contributed\\\");\\n        require(currentRound <= members.length, \\\"All rounds complete\\\");\\n\\n        hasPaid[msg.sender][currentRound] = true;\\n        totalContributed[msg.sender] += contributionAmount;\\n\\n        TokenTransfer.receiveTokens(tokenAddress, isNativeToken, contributionAmount);\\n\\n        emit ContributionMade(msg.sender, currentRound, contributionAmount);\\n\\n        if (_everyonePaid()) {\\n            emit AllMembersContributed(currentRound);\\n        }\\n    }\\n\\n    /**\\n     * @notice Triggers the payout for the current round\\n     * @dev Only the designated recipient can trigger their own payout\\n     * Requires all members to have contributed for the current round\\n     */\\n    function triggerPayout() external poolActive whenNotPaused nonReentrant {\\n        require(_everyonePaid(), \\\"Not everyone has paid\\\");\\n        require(!currentRoundPaidOut, \\\"Round already paid out\\\");\\n\\n        address recipient = payoutOrder[currentRound - 1];\\n        require(msg.sender == recipient, \\\"Only recipient can claim payout\\\");\\n\\n        currentRoundPaidOut = true;\\n        hasReceivedPayout[recipient] = true;\\n\\n        uint256 payoutAmount = contributionAmount * members.length;\\n\\n        TokenTransfer.sendTokens(tokenAddress, isNativeToken, recipient, payoutAmount);\\n\\n        emit PayoutTriggered(recipient, payoutAmount, currentRound);\\n\\n        // Check if ROSCA is complete\\n        if (currentRound >= members.length) {\\n            isComplete = true;\\n            isActive = false;\\n            emit ROSCACompleted(block.timestamp);\\n        }\\n    }\\n\\n    /**\\n     * @notice Starts the next round after the cycle duration has passed\\n     * @dev Any member can call this after the 30-day cycle is complete\\n     */\\n    function startNextRound() external onlyMember whenNotPaused {\\n        require(isActive && !isComplete, \\\"ROSCA not active\\\");\\n        require(currentRoundPaidOut, \\\"Current round not paid out\\\");\\n        require(currentRound < members.length, \\\"All rounds complete\\\");\\n        require(\\n            block.timestamp >= currentRoundStartTime + CYCLE_DURATION,\\n            \\\"30-day cycle not complete\\\"\\n        );\\n\\n        currentRound++;\\n        currentRoundStartTime = block.timestamp;\\n        currentRoundPaidOut = false;\\n\\n        emit RoundStarted(currentRound, block.timestamp);\\n    }\\n\\n    // ========== Emergency Functions ==========\\n\\n    /**\\n     * @notice Pauses the contract in case of emergency\\n     * @dev Only creator can pause\\n     */\\n    function pause() external onlyCreator {\\n        _pause();\\n    }\\n\\n    /**\\n     * @notice Unpauses the contract\\n     * @dev Only creator can unpause\\n     */\\n    function unpause() external onlyCreator {\\n        _unpause();\\n    }\\n\\n    // ========== View Functions ==========\\n\\n    /**\\n     * @notice Checks if everyone has paid for the current round\\n     * @return True if all members have contributed, false otherwise\\n     */\\n    function everyonePaid() external view returns (bool) {\\n        return _everyonePaid();\\n    }\\n\\n    /**\\n     * @notice Internal function to check if everyone has paid\\n     * @return True if all members have contributed, false otherwise\\n     */\\n    function _everyonePaid() private view returns (bool) {\\n        for (uint256 i = 0; i < members.length; i++) {\\n            if (!hasPaid[members[i]][currentRound]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Gets the current round's recipient\\n     * @return Address of the member who should receive payout this round\\n     */\\n    function getCurrentRecipient() external view returns (address) {\\n        if (currentRound == 0 || currentRound > payoutOrder.length) {\\n            return address(0);\\n        }\\n        return payoutOrder[currentRound - 1];\\n    }\\n\\n    /**\\n     * @notice Gets the total number of members\\n     * @return Member count\\n     */\\n    function getMemberCount() external view returns (uint256) {\\n        return members.length;\\n    }\\n\\n    /**\\n     * @notice Gets all members\\n     * @return Array of member addresses\\n     */\\n    function getMembers() external view returns (address[] memory) {\\n        return members;\\n    }\\n\\n    /**\\n     * @notice Gets the complete payout order\\n     * @return Array of addresses in payout order\\n     */\\n    function getPayoutOrder() external view returns (address[] memory) {\\n        return payoutOrder;\\n    }\\n\\n    /**\\n     * @notice Gets list of members who have contributed in the current round\\n     * @return Array of addresses who have paid\\n     */\\n    function getRoundContributors() external view returns (address[] memory) {\\n        uint256 contributorCount = 0;\\n\\n        // Count contributors\\n        for (uint256 i = 0; i < members.length; i++) {\\n            if (hasPaid[members[i]][currentRound]) {\\n                contributorCount++;\\n            }\\n        }\\n\\n        // Build contributor array\\n        address[] memory contributors = new address[](contributorCount);\\n        uint256 index = 0;\\n\\n        for (uint256 i = 0; i < members.length; i++) {\\n            if (hasPaid[members[i]][currentRound]) {\\n                contributors[index] = members[i];\\n                index++;\\n            }\\n        }\\n\\n        return contributors;\\n    }\\n\\n    /**\\n     * @notice Gets the contract's current balance\\n     * @return Balance in wei\\n     */\\n    function getBalance() external view returns (uint256) {\\n        return address(this).balance;\\n    }\\n}\\n\",\"keccak256\":\"0x176ad94e373a56387f4de87e157cba58234c3893a8d509387f07778e604a777b\",\"license\":\"MIT\"},\"contracts/pools/SavingsPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Pausable.sol\\\";\\nimport \\\"../interfaces/IXershaPool.sol\\\";\\nimport \\\"../libraries/TokenTransfer.sol\\\";\\n\\n/**\\n * @title SavingsPool\\n * @notice Collective savings pool where members can deposit and withdraw freely\\n * @dev Members maintain individual balances and can set collective savings goals\\n */\\ncontract SavingsPool is IXershaPool, ReentrancyGuard, Pausable {\\n    using TokenTransfer for address;\\n\\n    // ========== State Variables ==========\\n\\n    /// @notice Address of the user who created this pool\\n    address public creator;\\n\\n    /// @notice Address of the Lens.xyz circle contract\\n    address public circleId;\\n\\n    /// @notice Human-readable name of the circle\\n    string public circleName;\\n\\n    /// @notice Address of the ERC20 token used for savings (zero address if native token)\\n    address public tokenAddress;\\n\\n    /// @notice Whether this pool uses native token (cBTC) or ERC20 token\\n    bool public isNativeToken;\\n\\n    /// @notice Individual balances for each member\\n    mapping(address => uint256) public balances;\\n\\n    /// @notice Total amount saved across all members\\n    uint256 public totalSaved;\\n\\n    /// @notice Array of all members in the pool\\n    address[] public members;\\n\\n    /// @notice Mapping to check if an address is a member\\n    mapping(address => bool) public isMember;\\n\\n    /// @notice Mapping to check if an address has been invited\\n    mapping(address => bool) public isInvited;\\n\\n    /// @notice Optional target savings amount set by creator\\n    uint256 public targetAmount;\\n\\n    /// @notice Optional target date for reaching the goal\\n    uint256 public targetDate;\\n\\n    /// @notice Whether the pool is currently active\\n    bool public isActive;\\n\\n    /// @notice Whether this contract has been initialized (for clone pattern)\\n    bool private initialized;\\n\\n    // ========== Events ==========\\n\\n    event PoolCreated(address indexed circleId, address indexed creator);\\n    event MemberInvited(address indexed member, address indexed invitedBy);\\n    event MemberJoined(address indexed member);\\n    event Deposited(address indexed member, uint256 amount);\\n    event Withdrawn(address indexed member, uint256 amount);\\n    event TargetSet(uint256 amount, uint256 date);\\n    event PoolClosed(uint256 timestamp);\\n\\n    // ========== Modifiers ==========\\n\\n    modifier onlyCreator() {\\n        require(msg.sender == creator, \\\"Only creator can call this\\\");\\n        _;\\n    }\\n\\n    modifier onlyMember() {\\n        require(isMember[msg.sender], \\\"Not a member\\\");\\n        _;\\n    }\\n\\n    modifier onlyInvited() {\\n        require(isInvited[msg.sender], \\\"Not invited\\\");\\n        _;\\n    }\\n\\n    modifier poolIsActive() {\\n        require(isActive, \\\"Pool not active\\\");\\n        _;\\n    }\\n\\n    // ========== Constructor ==========\\n\\n    /**\\n     * @notice Constructor for implementation contract\\n     * @dev Prevents the implementation contract from being initialized\\n     */\\n    constructor() {\\n        initialized = true;\\n    }\\n\\n    /**\\n     * @notice Initializes a new Savings pool clone\\n     * @dev This replaces the constructor for cloned instances\\n     * @param _creator Address of the user creating the pool\\n     * @param _circleId Address of the Lens.xyz circle contract\\n     * @param _circleName Name of the circle\\n     * @param _tokenAddress Address of the ERC20 token to use for savings (zero address if native)\\n     * @param _isNativeToken Whether this pool uses native token (cBTC) or ERC20 token\\n     */\\n    function initialize(\\n        address _creator,\\n        address _circleId,\\n        string memory _circleName,\\n        address _tokenAddress,\\n        bool _isNativeToken\\n    ) external {\\n        require(!initialized, \\\"Already initialized\\\");\\n        initialized = true;\\n\\n        // Validate token address based on token type\\n        if (_isNativeToken) {\\n            require(_tokenAddress == address(0), \\\"Token address must be zero for native token\\\");\\n        } else {\\n            require(_tokenAddress != address(0), \\\"Invalid token address for ERC20\\\");\\n        }\\n\\n        creator = _creator;\\n        circleId = _circleId;\\n        circleName = _circleName;\\n        tokenAddress = _tokenAddress;\\n        isNativeToken = _isNativeToken;\\n        isActive = true;\\n\\n        // Creator automatically becomes a member\\n        members.push(_creator);\\n        isMember[_creator] = true;\\n        isInvited[_creator] = true;\\n\\n        emit PoolCreated(_circleId, _creator);\\n        emit MemberJoined(_creator);\\n    }\\n\\n    // ========== Member Management ==========\\n\\n    /**\\n     * @notice Invites a new member to the pool\\n     * @dev Only creator can invite members\\n     * @param member Address of the member to invite\\n     */\\n    function inviteMember(address member) external onlyCreator whenNotPaused {\\n        require(!isInvited[member], \\\"Already invited\\\");\\n        require(member != address(0), \\\"Invalid address\\\");\\n\\n        isInvited[member] = true;\\n        emit MemberInvited(member, creator);\\n    }\\n\\n    /**\\n     * @notice Allows an invited member to join the pool\\n     */\\n    function joinPool() external onlyInvited whenNotPaused {\\n        require(!isMember[msg.sender], \\\"Already a member\\\");\\n\\n        members.push(msg.sender);\\n        isMember[msg.sender] = true;\\n\\n        emit MemberJoined(msg.sender);\\n    }\\n\\n    // ========== Deposits & Withdrawals ==========\\n\\n    /**\\n     * @notice Allows a member to deposit funds into their savings\\n     * @dev For ERC20: Member must have approved the contract to spend tokens before calling\\n     *      For native token: amount parameter is ignored, msg.value is used\\n     * @param amount Amount of ERC20 tokens to deposit (ignored for native token pools)\\n     */\\n    function deposit(uint256 amount) external payable onlyMember poolIsActive whenNotPaused nonReentrant {\\n        require(isNativeToken || amount > 0, \\\"Must deposit something\\\");\\n\\n        uint256 depositAmount = TokenTransfer.receiveTokens(tokenAddress, isNativeToken, amount);\\n\\n        balances[msg.sender] += depositAmount;\\n        totalSaved += depositAmount;\\n\\n        emit Deposited(msg.sender, depositAmount);\\n    }\\n\\n    /**\\n     * @notice Allows a member to withdraw from their savings balance\\n     * @param amount Amount of tokens to withdraw\\n     */\\n    function withdraw(uint256 amount) external onlyMember whenNotPaused nonReentrant {\\n        require(amount > 0, \\\"Must withdraw something\\\");\\n        require(balances[msg.sender] >= amount, \\\"Insufficient balance\\\");\\n\\n        balances[msg.sender] -= amount;\\n        totalSaved -= amount;\\n\\n        TokenTransfer.sendTokens(tokenAddress, isNativeToken, msg.sender, amount);\\n\\n        emit Withdrawn(msg.sender, amount);\\n    }\\n\\n    // ========== Goal Management ==========\\n\\n    /**\\n     * @notice Sets or updates the savings goal for the pool\\n     * @dev Only creator can set goals\\n     * @param _amount Target savings amount in wei\\n     * @param _date Target date as Unix timestamp\\n     */\\n    function setTarget(uint256 _amount, uint256 _date) external onlyCreator whenNotPaused {\\n        require(_amount > 0, \\\"Target amount must be positive\\\");\\n        require(_date > block.timestamp, \\\"Target date must be in future\\\");\\n\\n        targetAmount = _amount;\\n        targetDate = _date;\\n\\n        emit TargetSet(_amount, _date);\\n    }\\n\\n    // ========== Pool Management ==========\\n\\n    /**\\n     * @notice Closes the pool, preventing further deposits\\n     * @dev Only creator can close. Members can still withdraw their balances.\\n     */\\n    function closePool() external onlyCreator whenNotPaused {\\n        isActive = false;\\n        emit PoolClosed(block.timestamp);\\n    }\\n\\n    /**\\n     * @notice Pauses the contract in case of emergency\\n     * @dev Only creator can pause\\n     */\\n    function pause() external onlyCreator {\\n        _pause();\\n    }\\n\\n    /**\\n     * @notice Unpauses the contract\\n     * @dev Only creator can unpause\\n     */\\n    function unpause() external onlyCreator {\\n        _unpause();\\n    }\\n\\n    // ========== View Functions ==========\\n\\n    /**\\n     * @notice Gets a member's savings balance\\n     * @param member Address of the member\\n     * @return Balance in wei\\n     */\\n    function getBalance(address member) external view returns (uint256) {\\n        return balances[member];\\n    }\\n\\n    /**\\n     * @notice Gets the total number of members\\n     * @return Member count\\n     */\\n    function getMemberCount() external view returns (uint256) {\\n        return members.length;\\n    }\\n\\n    /**\\n     * @notice Gets all members\\n     * @return Array of member addresses\\n     */\\n    function getMembers() external view returns (address[] memory) {\\n        return members;\\n    }\\n\\n    /**\\n     * @notice Gets the current progress toward the savings goal\\n     * @return current Current total savings\\n     * @return target Target savings amount\\n     */\\n    function getProgress() external view returns (uint256 current, uint256 target) {\\n        return (totalSaved, targetAmount);\\n    }\\n\\n    /**\\n     * @notice Checks if the savings goal has been reached\\n     * @return True if target is set and reached, false otherwise\\n     */\\n    function isGoalReached() external view returns (bool) {\\n        if (targetAmount == 0) return false;\\n        return totalSaved >= targetAmount;\\n    }\\n\\n    /**\\n     * @notice Gets the contract's current balance\\n     * @return Balance in wei\\n     */\\n    function getContractBalance() external view returns (uint256) {\\n        return address(this).balance;\\n    }\\n}\\n\",\"keccak256\":\"0xf198ed14ef66138b4511f791e655dda4485ad383d6105eb52ca271bb9d717de7\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60806040523480156200001157600080fd5b50604051620016363803806200163683398101604081905262000034916200022a565b836001600160a01b0381166200006557604051631e4fbdf760e01b8152600060048201526024015b60405180910390fd5b6200007081620001bd565b506001600160a01b038316620000c95760405162461bcd60e51b815260206004820152601c60248201527f496e76616c696420524f53434120696d706c656d656e746174696f6e0000000060448201526064016200005c565b6001600160a01b038216620001215760405162461bcd60e51b815260206004820152601e60248201527f496e76616c696420536176696e677320696d706c656d656e746174696f6e000060448201526064016200005c565b6001600160a01b038116620001795760405162461bcd60e51b815260206004820152601f60248201527f496e76616c696420446f6e6174696f6e20696d706c656d656e746174696f6e0060448201526064016200005c565b600180546001600160a01b039485166001600160a01b0319918216179091556002805493851693821693909317909255600380549190931691161790555062000287565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b80516001600160a01b03811681146200022557600080fd5b919050565b600080600080608085870312156200024157600080fd5b6200024c856200020d565b93506200025c602086016200020d565b92506200026c604086016200020d565b91506200027c606086016200020d565b905092959194509250565b61139f80620002976000396000f3fe608060405234801561001057600080fd5b50600436106101375760003560e01c80638da5cb5b116100b8578063ca84b47f1161007c578063ca84b47f146102a8578063ce7ae1f9146102bb578063d3ffe67a146102e4578063d88ff1f4146102f5578063eb0227be1461030a578063f2fde38b1461033657600080fd5b80638da5cb5b1461024b5780639300d2381461025c578063a71b32421461026f578063aab050d814610282578063ba6c5e711461029557600080fd5b80635490ad99116100ff5780635490ad99146101d75780635ab78ee1146101ea578063715018a61461021d57806387f26142146102255780638b2d16eb1461023857600080fd5b806329c154451461013c5780632aca2b331461015157806341d1de971461018157806344b403ea146101945780635328d28c146101c4575b600080fd5b61014f61014a366004610e78565b610349565b005b61016461015f366004610f4d565b6103e3565b6040516001600160a01b0390911681526020015b60405180910390f35b61016461018f366004610fe0565b6105e8565b6101b76101a2366004610e78565b60066020526000908152604090205460ff1681565b604051610178919061100f565b600354610164906001600160a01b031681565b6101646101e5366004611037565b610612565b61020d6101f8366004610e78565b60056020526000908152604090205460ff1681565b6040519015158152602001610178565b61014f610794565b6101646102333660046110b0565b6107a8565b61014f610246366004610e78565b6108d7565b6000546001600160a01b0316610164565b61014f61026a36600461111f565b61095c565b6101b761027d366004610e78565b610ab5565b600154610164906001600160a01b031681565b600254610164906001600160a01b031681565b61014f6102b6366004610e78565b610b33565b6101646102c9366004610e78565b6004602052600090815260409020546001600160a01b031681565b600754604051908152602001610178565b6102fd610bb6565b6040516101789190611162565b610164610318366004610e78565b6001600160a01b039081166000908152600460205260409020541690565b61014f610344366004610e78565b610c18565b610351610c56565b6001600160a01b0381166103805760405162461bcd60e51b8152600401610377906111af565b60405180910390fd5b600380546001600160a01b0383166001600160a01b0319909116811790915560405160008051602061134a833981519152906103d8906020808252600890820152672227a720aa24a7a760c11b604082015260600190565b60405180910390a250565b60006103ee88610c83565b6001600160a01b0388811660009081526004602052604090205416156104265760405162461bcd60e51b8152600401610377906111df565b6001600160a01b0386166104725760405162461bcd60e51b8152602060048201526013602482015272496e76616c69642062656e656669636961727960681b6044820152606401610377565b600085116104b15760405162461bcd60e51b815260206004820152600c60248201526b125b9d985b1a590819dbd85b60a21b6044820152606401610377565b4284116104f35760405162461bcd60e51b815260206004820152601060248201526f496e76616c696420646561646c696e6560801b6044820152606401610377565b60035460009061050b906001600160a01b0316610cd9565b604051630df8719f60e01b81529091506001600160a01b03821690630df8719f906105489033908d908d908d908d908d908d908d9060040161125c565b600060405180830381600087803b15801561056257600080fd5b505af1158015610576573d6000803e3d6000fd5b5050505061058689826002610d4b565b336001600160a01b0316816001600160a01b03168a6001600160a01b03167f645ee41665486bc487a04a91a2bd296d2d2395cabf7747b152436dd15f9d4f8f60026040516105d4919061100f565b60405180910390a498975050505050505050565b600781815481106105f857600080fd5b6000918252602090912001546001600160a01b0316905081565b600061061d86610c83565b6001600160a01b0386811660009081526004602052604090205416156106555760405162461bcd60e51b8152600401610377906111df565b600084116106a55760405162461bcd60e51b815260206004820152601b60248201527f496e76616c696420636f6e747269627574696f6e20616d6f756e7400000000006044820152606401610377565b6001546000906106bd906001600160a01b0316610cd9565b60405163016d3a9960e41b81529091506001600160a01b038216906316d3a990906106f69033908b908b908b908b908b906004016112bb565b600060405180830381600087803b15801561071057600080fd5b505af1158015610724573d6000803e3d6000fd5b5050505061073487826000610d4b565b336001600160a01b0316816001600160a01b0316886001600160a01b03167f645ee41665486bc487a04a91a2bd296d2d2395cabf7747b152436dd15f9d4f8f6000604051610782919061100f565b60405180910390a49695505050505050565b61079c610c56565b6107a66000610e11565b565b60006107b385610c83565b6001600160a01b0385811660009081526004602052604090205416156107eb5760405162461bcd60e51b8152600401610377906111df565b600254600090610803906001600160a01b0316610cd9565b6040516304c2956b60e41b81529091506001600160a01b03821690634c2956b09061083a9033908a908a908a908a90600401611307565b600060405180830381600087803b15801561085457600080fd5b505af1158015610868573d6000803e3d6000fd5b5050505061087886826001610d4b565b336001600160a01b0316816001600160a01b0316876001600160a01b03167f645ee41665486bc487a04a91a2bd296d2d2395cabf7747b152436dd15f9d4f8f60016040516108c6919061100f565b60405180910390a495945050505050565b6108df610c56565b6001600160a01b0381166109055760405162461bcd60e51b8152600401610377906111af565b600280546001600160a01b0383166001600160a01b0319909116811790915560405160008051602061134a833981519152906103d890602080825260079082015266534156494e475360c81b604082015260600190565b610964610c56565b6001600160a01b038316156109d157600180546001600160a01b0385166001600160a01b0319909116811790915560405160008051602061134a833981519152906109c890602080825260059082015264524f53434160d81b604082015260600190565b60405180910390a25b6001600160a01b03821615610a4057600280546001600160a01b0384166001600160a01b0319909116811790915560405160008051602061134a83398151915290610a3790602080825260079082015266534156494e475360c81b604082015260600190565b60405180910390a25b6001600160a01b03811615610ab057600380546001600160a01b0383166001600160a01b0319909116811790915560405160008051602061134a83398151915290610aa7906020808252600890820152672227a720aa24a7a760c11b604082015260600190565b60405180910390a25b505050565b6001600160a01b03811660009081526005602052604081205460ff16610b145760405162461bcd60e51b8152602060048201526014602482015273496e76616c696420706f6f6c206164647265737360601b6044820152606401610377565b506001600160a01b031660009081526006602052604090205460ff1690565b610b3b610c56565b6001600160a01b038116610b615760405162461bcd60e51b8152600401610377906111af565b600180546001600160a01b0383166001600160a01b0319909116811790915560405160008051602061134a833981519152906103d890602080825260059082015264524f53434160d81b604082015260600190565b60606007805480602002602001604051908101604052809291908181526020018280548015610c0e57602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311610bf0575b5050505050905090565b610c20610c56565b6001600160a01b038116610c4a57604051631e4fbdf760e01b815260006004820152602401610377565b610c5381610e11565b50565b6000546001600160a01b031633146107a65760405163118cdaa760e01b8152336004820152602401610377565b6001600160a01b038116610c535760405162461bcd60e51b815260206004820152601860248201527f5a65726f2061646472657373206e6f7420616c6c6f77656400000000000000006044820152606401610377565b6000763d602d80600a3d3981f3363d3d373d3d3d363d730000008260601b60e81c176000526e5af43d82803e903d91602b57fd5bf38260781b17602052603760096000f090506001600160a01b038116610d46576040516330be1a3d60e21b815260040160405180910390fd5b919050565b6001600160a01b03838116600090815260046020908152604080832080546001600160a01b031916948716948517905592825260058152828220805460ff1990811660019081179092556006909252929091208054849391921690836002811115610db857610db8610ff9565b021790555050600780546001810182556000919091527fa66cc928b5edb82af9bd49922954155ab7b0942694bea4ce44661d9a8736c6880180546001600160a01b0319166001600160a01b039290921691909117905550565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b80356001600160a01b0381168114610d4657600080fd5b600060208284031215610e8a57600080fd5b610e9382610e61565b9392505050565b634e487b7160e01b600052604160045260246000fd5b600082601f830112610ec157600080fd5b813567ffffffffffffffff80821115610edc57610edc610e9a565b604051601f8301601f19908116603f01168101908282118183101715610f0457610f04610e9a565b81604052838152866020858801011115610f1d57600080fd5b836020870160208301376000602085830101528094505050505092915050565b80358015158114610d4657600080fd5b600080600080600080600060e0888a031215610f6857600080fd5b610f7188610e61565b9650602088013567ffffffffffffffff811115610f8d57600080fd5b610f998a828b01610eb0565b965050610fa860408901610e61565b94506060880135935060808801359250610fc460a08901610e61565b9150610fd260c08901610f3d565b905092959891949750929550565b600060208284031215610ff257600080fd5b5035919050565b634e487b7160e01b600052602160045260246000fd5b602081016003831061103157634e487b7160e01b600052602160045260246000fd5b91905290565b600080600080600060a0868803121561104f57600080fd5b61105886610e61565b9450602086013567ffffffffffffffff81111561107457600080fd5b61108088828901610eb0565b9450506040860135925061109660608701610e61565b91506110a460808701610f3d565b90509295509295909350565b600080600080608085870312156110c657600080fd5b6110cf85610e61565b9350602085013567ffffffffffffffff8111156110eb57600080fd5b6110f787828801610eb0565b93505061110660408601610e61565b915061111460608601610f3d565b905092959194509250565b60008060006060848603121561113457600080fd5b61113d84610e61565b925061114b60208501610e61565b915061115960408501610e61565b90509250925092565b6020808252825182820181905260009190848201906040850190845b818110156111a35783516001600160a01b03168352928401929184019160010161117e565b50909695505050505050565b60208082526016908201527524b73b30b634b21034b6b83632b6b2b73a30ba34b7b760511b604082015260600190565b60208082526017908201527f436972636c6520616c72656164792068617320706f6f6c000000000000000000604082015260600190565b6000815180845260005b8181101561123c57602081850181015186830182015201611220565b506000602082860101526020601f19601f83011685010191505092915050565b6001600160a01b03898116825288811660208301526101006040830181905260009161128a8483018b611216565b98811660608501526080840197909752505060a0810193909352921660c082015290151560e0909101529392505050565b600060018060a01b038089168352808816602084015260c060408401526112e560c0840188611216565b606084019690965293909316608082015290151560a090910152509392505050565b600060018060a01b038088168352808716602084015260a0604084015261133160a0840187611216565b9416606083015250901515608090910152939250505056fea1e41aa2c2f3f20d9b63ac06b634d2788768d6034f3d9192cdf7d07374bb16f4a264697066735822122054e92040ccf7bab0939ceb9691802c2e8a90c10e1b63fc4ccbeeac1420a1489d64736f6c63430008140033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101375760003560e01c80638da5cb5b116100b8578063ca84b47f1161007c578063ca84b47f146102a8578063ce7ae1f9146102bb578063d3ffe67a146102e4578063d88ff1f4146102f5578063eb0227be1461030a578063f2fde38b1461033657600080fd5b80638da5cb5b1461024b5780639300d2381461025c578063a71b32421461026f578063aab050d814610282578063ba6c5e711461029557600080fd5b80635490ad99116100ff5780635490ad99146101d75780635ab78ee1146101ea578063715018a61461021d57806387f26142146102255780638b2d16eb1461023857600080fd5b806329c154451461013c5780632aca2b331461015157806341d1de971461018157806344b403ea146101945780635328d28c146101c4575b600080fd5b61014f61014a366004610e78565b610349565b005b61016461015f366004610f4d565b6103e3565b6040516001600160a01b0390911681526020015b60405180910390f35b61016461018f366004610fe0565b6105e8565b6101b76101a2366004610e78565b60066020526000908152604090205460ff1681565b604051610178919061100f565b600354610164906001600160a01b031681565b6101646101e5366004611037565b610612565b61020d6101f8366004610e78565b60056020526000908152604090205460ff1681565b6040519015158152602001610178565b61014f610794565b6101646102333660046110b0565b6107a8565b61014f610246366004610e78565b6108d7565b6000546001600160a01b0316610164565b61014f61026a36600461111f565b61095c565b6101b761027d366004610e78565b610ab5565b600154610164906001600160a01b031681565b600254610164906001600160a01b031681565b61014f6102b6366004610e78565b610b33565b6101646102c9366004610e78565b6004602052600090815260409020546001600160a01b031681565b600754604051908152602001610178565b6102fd610bb6565b6040516101789190611162565b610164610318366004610e78565b6001600160a01b039081166000908152600460205260409020541690565b61014f610344366004610e78565b610c18565b610351610c56565b6001600160a01b0381166103805760405162461bcd60e51b8152600401610377906111af565b60405180910390fd5b600380546001600160a01b0383166001600160a01b0319909116811790915560405160008051602061134a833981519152906103d8906020808252600890820152672227a720aa24a7a760c11b604082015260600190565b60405180910390a250565b60006103ee88610c83565b6001600160a01b0388811660009081526004602052604090205416156104265760405162461bcd60e51b8152600401610377906111df565b6001600160a01b0386166104725760405162461bcd60e51b8152602060048201526013602482015272496e76616c69642062656e656669636961727960681b6044820152606401610377565b600085116104b15760405162461bcd60e51b815260206004820152600c60248201526b125b9d985b1a590819dbd85b60a21b6044820152606401610377565b4284116104f35760405162461bcd60e51b815260206004820152601060248201526f496e76616c696420646561646c696e6560801b6044820152606401610377565b60035460009061050b906001600160a01b0316610cd9565b604051630df8719f60e01b81529091506001600160a01b03821690630df8719f906105489033908d908d908d908d908d908d908d9060040161125c565b600060405180830381600087803b15801561056257600080fd5b505af1158015610576573d6000803e3d6000fd5b5050505061058689826002610d4b565b336001600160a01b0316816001600160a01b03168a6001600160a01b03167f645ee41665486bc487a04a91a2bd296d2d2395cabf7747b152436dd15f9d4f8f60026040516105d4919061100f565b60405180910390a498975050505050505050565b600781815481106105f857600080fd5b6000918252602090912001546001600160a01b0316905081565b600061061d86610c83565b6001600160a01b0386811660009081526004602052604090205416156106555760405162461bcd60e51b8152600401610377906111df565b600084116106a55760405162461bcd60e51b815260206004820152601b60248201527f496e76616c696420636f6e747269627574696f6e20616d6f756e7400000000006044820152606401610377565b6001546000906106bd906001600160a01b0316610cd9565b60405163016d3a9960e41b81529091506001600160a01b038216906316d3a990906106f69033908b908b908b908b908b906004016112bb565b600060405180830381600087803b15801561071057600080fd5b505af1158015610724573d6000803e3d6000fd5b5050505061073487826000610d4b565b336001600160a01b0316816001600160a01b0316886001600160a01b03167f645ee41665486bc487a04a91a2bd296d2d2395cabf7747b152436dd15f9d4f8f6000604051610782919061100f565b60405180910390a49695505050505050565b61079c610c56565b6107a66000610e11565b565b60006107b385610c83565b6001600160a01b0385811660009081526004602052604090205416156107eb5760405162461bcd60e51b8152600401610377906111df565b600254600090610803906001600160a01b0316610cd9565b6040516304c2956b60e41b81529091506001600160a01b03821690634c2956b09061083a9033908a908a908a908a90600401611307565b600060405180830381600087803b15801561085457600080fd5b505af1158015610868573d6000803e3d6000fd5b5050505061087886826001610d4b565b336001600160a01b0316816001600160a01b0316876001600160a01b03167f645ee41665486bc487a04a91a2bd296d2d2395cabf7747b152436dd15f9d4f8f60016040516108c6919061100f565b60405180910390a495945050505050565b6108df610c56565b6001600160a01b0381166109055760405162461bcd60e51b8152600401610377906111af565b600280546001600160a01b0383166001600160a01b0319909116811790915560405160008051602061134a833981519152906103d890602080825260079082015266534156494e475360c81b604082015260600190565b610964610c56565b6001600160a01b038316156109d157600180546001600160a01b0385166001600160a01b0319909116811790915560405160008051602061134a833981519152906109c890602080825260059082015264524f53434160d81b604082015260600190565b60405180910390a25b6001600160a01b03821615610a4057600280546001600160a01b0384166001600160a01b0319909116811790915560405160008051602061134a83398151915290610a3790602080825260079082015266534156494e475360c81b604082015260600190565b60405180910390a25b6001600160a01b03811615610ab057600380546001600160a01b0383166001600160a01b0319909116811790915560405160008051602061134a83398151915290610aa7906020808252600890820152672227a720aa24a7a760c11b604082015260600190565b60405180910390a25b505050565b6001600160a01b03811660009081526005602052604081205460ff16610b145760405162461bcd60e51b8152602060048201526014602482015273496e76616c696420706f6f6c206164647265737360601b6044820152606401610377565b506001600160a01b031660009081526006602052604090205460ff1690565b610b3b610c56565b6001600160a01b038116610b615760405162461bcd60e51b8152600401610377906111af565b600180546001600160a01b0383166001600160a01b0319909116811790915560405160008051602061134a833981519152906103d890602080825260059082015264524f53434160d81b604082015260600190565b60606007805480602002602001604051908101604052809291908181526020018280548015610c0e57602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311610bf0575b5050505050905090565b610c20610c56565b6001600160a01b038116610c4a57604051631e4fbdf760e01b815260006004820152602401610377565b610c5381610e11565b50565b6000546001600160a01b031633146107a65760405163118cdaa760e01b8152336004820152602401610377565b6001600160a01b038116610c535760405162461bcd60e51b815260206004820152601860248201527f5a65726f2061646472657373206e6f7420616c6c6f77656400000000000000006044820152606401610377565b6000763d602d80600a3d3981f3363d3d373d3d3d363d730000008260601b60e81c176000526e5af43d82803e903d91602b57fd5bf38260781b17602052603760096000f090506001600160a01b038116610d46576040516330be1a3d60e21b815260040160405180910390fd5b919050565b6001600160a01b03838116600090815260046020908152604080832080546001600160a01b031916948716948517905592825260058152828220805460ff1990811660019081179092556006909252929091208054849391921690836002811115610db857610db8610ff9565b021790555050600780546001810182556000919091527fa66cc928b5edb82af9bd49922954155ab7b0942694bea4ce44661d9a8736c6880180546001600160a01b0319166001600160a01b039290921691909117905550565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b80356001600160a01b0381168114610d4657600080fd5b600060208284031215610e8a57600080fd5b610e9382610e61565b9392505050565b634e487b7160e01b600052604160045260246000fd5b600082601f830112610ec157600080fd5b813567ffffffffffffffff80821115610edc57610edc610e9a565b604051601f8301601f19908116603f01168101908282118183101715610f0457610f04610e9a565b81604052838152866020858801011115610f1d57600080fd5b836020870160208301376000602085830101528094505050505092915050565b80358015158114610d4657600080fd5b600080600080600080600060e0888a031215610f6857600080fd5b610f7188610e61565b9650602088013567ffffffffffffffff811115610f8d57600080fd5b610f998a828b01610eb0565b965050610fa860408901610e61565b94506060880135935060808801359250610fc460a08901610e61565b9150610fd260c08901610f3d565b905092959891949750929550565b600060208284031215610ff257600080fd5b5035919050565b634e487b7160e01b600052602160045260246000fd5b602081016003831061103157634e487b7160e01b600052602160045260246000fd5b91905290565b600080600080600060a0868803121561104f57600080fd5b61105886610e61565b9450602086013567ffffffffffffffff81111561107457600080fd5b61108088828901610eb0565b9450506040860135925061109660608701610e61565b91506110a460808701610f3d565b90509295509295909350565b600080600080608085870312156110c657600080fd5b6110cf85610e61565b9350602085013567ffffffffffffffff8111156110eb57600080fd5b6110f787828801610eb0565b93505061110660408601610e61565b915061111460608601610f3d565b905092959194509250565b60008060006060848603121561113457600080fd5b61113d84610e61565b925061114b60208501610e61565b915061115960408501610e61565b90509250925092565b6020808252825182820181905260009190848201906040850190845b818110156111a35783516001600160a01b03168352928401929184019160010161117e565b50909695505050505050565b60208082526016908201527524b73b30b634b21034b6b83632b6b2b73a30ba34b7b760511b604082015260600190565b60208082526017908201527f436972636c6520616c72656164792068617320706f6f6c000000000000000000604082015260600190565b6000815180845260005b8181101561123c57602081850181015186830182015201611220565b506000602082860101526020601f19601f83011685010191505092915050565b6001600160a01b03898116825288811660208301526101006040830181905260009161128a8483018b611216565b98811660608501526080840197909752505060a0810193909352921660c082015290151560e0909101529392505050565b600060018060a01b038089168352808816602084015260c060408401526112e560c0840188611216565b606084019690965293909316608082015290151560a090910152509392505050565b600060018060a01b038088168352808716602084015260a0604084015261133160a0840187611216565b9416606083015250901515608090910152939250505056fea1e41aa2c2f3f20d9b63ac06b634d2788768d6034f3d9192cdf7d07374bb16f4a264697066735822122054e92040ccf7bab0939ceb9691802c2e8a90c10e1b63fc4ccbeeac1420a1489d64736f6c63430008140033",
  "devdoc": {
    "details": "Enforces one pool per circle and tracks all deployed pools      Uses EIP-1167 minimal proxies (clones) for gas-efficient pool deployment",
    "errors": {
      "ERC1167FailedCreateClone()": [
        {
          "details": "A clone instance deployment failed."
        }
      ],
      "OwnableInvalidOwner(address)": [
        {
          "details": "The owner is not a valid owner account. (eg. `address(0)`)"
        }
      ],
      "OwnableUnauthorizedAccount(address)": [
        {
          "details": "The caller account is not authorized to perform an operation."
        }
      ]
    },
    "events": {
      "ImplementationUpdated(string,address)": {
        "params": {
          "newImplementation": "The new implementation address",
          "poolType": "The type of pool implementation that was updated"
        }
      },
      "PoolCreated(address,address,address,uint8)": {
        "params": {
          "circleId": "The Lens.xyz circle contract address",
          "creator": "The address that created the pool",
          "poolAddress": "The address of the newly created pool",
          "poolType": "The type of pool created (ROSCA, SAVINGS, or DONATION)"
        }
      }
    },
    "kind": "dev",
    "methods": {
      "constructor": {
        "params": {
          "_donationImpl": "Address of the Donation pool implementation",
          "_roscaImpl": "Address of the ROSCA pool implementation",
          "_savingsImpl": "Address of the Savings pool implementation",
          "initialOwner": "Address that will own the factory"
        }
      },
      "createDonationPool(address,string,address,uint256,uint256,address,bool)": {
        "details": "Validates circle ID and ensures no duplicate pools for the same circle      Uses EIP-1167 minimal proxy pattern for gas-efficient deployment",
        "params": {
          "beneficiary": "The address that will receive the donated funds",
          "circleId": "The Lens.xyz circle contract address",
          "circleName": "The name of the circle",
          "deadline": "Unix timestamp when fundraising ends",
          "goalAmount": "The fundraising goal amount in wei",
          "isNativeToken": "Whether to use native token or ERC20",
          "tokenAddress": "Address of the ERC20 token (zero address if native)"
        },
        "returns": {
          "_0": "The address of the newly created Donation pool clone"
        }
      },
      "createROSCA(address,string,uint256,address,bool)": {
        "details": "Validates circle ID and ensures no duplicate pools for the same circle      Uses EIP-1167 minimal proxy pattern for gas-efficient deployment",
        "params": {
          "circleId": "The Lens.xyz circle contract address",
          "circleName": "The name of the circle",
          "contributionAmount": "Fixed amount each member must contribute per round",
          "isNativeToken": "Whether to use native token or ERC20",
          "tokenAddress": "Address of the ERC20 token (zero address if native)"
        },
        "returns": {
          "_0": "The address of the newly created ROSCA pool clone"
        }
      },
      "createSavingsPool(address,string,address,bool)": {
        "details": "Validates circle ID and ensures no duplicate pools for the same circle      Uses EIP-1167 minimal proxy pattern for gas-efficient deployment",
        "params": {
          "circleId": "The Lens.xyz circle contract address",
          "circleName": "The name of the circle",
          "isNativeToken": "Whether to use native token or ERC20",
          "tokenAddress": "Address of the ERC20 token (zero address if native)"
        },
        "returns": {
          "_0": "The address of the newly created Savings pool clone"
        }
      },
      "getAllPools()": {
        "details": "Warning: This can be gas-intensive for large numbers of pools",
        "returns": {
          "_0": "Array of all pool addresses"
        }
      },
      "getCirclePool(address)": {
        "params": {
          "circleId": "The circle contract address"
        },
        "returns": {
          "_0": "The pool address, or zero address if no pool exists"
        }
      },
      "getPoolType(address)": {
        "params": {
          "poolAddress": "The pool address to query"
        },
        "returns": {
          "_0": "The PoolType enum value"
        }
      },
      "getTotalPools()": {
        "returns": {
          "_0": "The total pool count"
        }
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."
      },
      "setDonationImplementation(address)": {
        "details": "Only owner can update. New pools will use the new implementation",
        "params": {
          "newImplementation": "Address of the new Donation implementation"
        }
      },
      "setImplementations(address,address,address)": {
        "details": "Only owner can update. Pass address(0) to skip updating a specific implementation",
        "params": {
          "_donationImpl": "New Donation implementation (or address(0) to skip)",
          "_roscaImpl": "New ROSCA implementation (or address(0) to skip)",
          "_savingsImpl": "New Savings implementation (or address(0) to skip)"
        }
      },
      "setROSCAImplementation(address)": {
        "details": "Only owner can update. New pools will use the new implementation",
        "params": {
          "newImplementation": "Address of the new ROSCA implementation"
        }
      },
      "setSavingsImplementation(address)": {
        "details": "Only owner can update. New pools will use the new implementation",
        "params": {
          "newImplementation": "Address of the new Savings implementation"
        }
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      }
    },
    "title": "XershaFactory",
    "version": 1
  },
  "userdoc": {
    "events": {
      "ImplementationUpdated(string,address)": {
        "notice": "Emitted when an implementation address is updated"
      },
      "PoolCreated(address,address,address,uint8)": {
        "notice": "Emitted when a new pool is created"
      }
    },
    "kind": "user",
    "methods": {
      "allPools(uint256)": {
        "notice": "Array of all pools created by this factory"
      },
      "circleToPool(address)": {
        "notice": "Mapping from circle contract address to pool address"
      },
      "constructor": {
        "notice": "Initializes the factory with implementation addresses"
      },
      "createDonationPool(address,string,address,uint256,uint256,address,bool)": {
        "notice": "Creates a new Donation pool for group fundraising"
      },
      "createROSCA(address,string,uint256,address,bool)": {
        "notice": "Creates a new ROSCA (Rotating Savings and Credit Association) pool"
      },
      "createSavingsPool(address,string,address,bool)": {
        "notice": "Creates a new Savings pool for collective savings"
      },
      "donationImplementation()": {
        "notice": "Implementation contract for Donation pools"
      },
      "getAllPools()": {
        "notice": "Gets all pool addresses created by this factory"
      },
      "getCirclePool(address)": {
        "notice": "Gets the pool address for a given circle"
      },
      "getPoolType(address)": {
        "notice": "Gets the pool type for a given pool address"
      },
      "getTotalPools()": {
        "notice": "Gets the total number of pools created by this factory"
      },
      "isValidPool(address)": {
        "notice": "Mapping to validate if an address is a legitimate pool created by this factory"
      },
      "poolTypes(address)": {
        "notice": "Mapping from pool address to pool type"
      },
      "roscaImplementation()": {
        "notice": "Implementation contract for ROSCA pools"
      },
      "savingsImplementation()": {
        "notice": "Implementation contract for Savings pools"
      },
      "setDonationImplementation(address)": {
        "notice": "Updates the Donation pool implementation address"
      },
      "setImplementations(address,address,address)": {
        "notice": "Updates all implementation addresses at once"
      },
      "setROSCAImplementation(address)": {
        "notice": "Updates the ROSCA pool implementation address"
      },
      "setSavingsImplementation(address)": {
        "notice": "Updates the Savings pool implementation address"
      }
    },
    "notice": "Factory contract for creating and managing Xersha pools using minimal proxy pattern",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 8,
        "contract": "contracts/XershaFactory.sol:XershaFactory",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 1913,
        "contract": "contracts/XershaFactory.sol:XershaFactory",
        "label": "roscaImplementation",
        "offset": 0,
        "slot": "1",
        "type": "t_address"
      },
      {
        "astId": 1916,
        "contract": "contracts/XershaFactory.sol:XershaFactory",
        "label": "savingsImplementation",
        "offset": 0,
        "slot": "2",
        "type": "t_address"
      },
      {
        "astId": 1919,
        "contract": "contracts/XershaFactory.sol:XershaFactory",
        "label": "donationImplementation",
        "offset": 0,
        "slot": "3",
        "type": "t_address"
      },
      {
        "astId": 1924,
        "contract": "contracts/XershaFactory.sol:XershaFactory",
        "label": "circleToPool",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_address,t_address)"
      },
      {
        "astId": 1929,
        "contract": "contracts/XershaFactory.sol:XershaFactory",
        "label": "isValidPool",
        "offset": 0,
        "slot": "5",
        "type": "t_mapping(t_address,t_bool)"
      },
      {
        "astId": 1935,
        "contract": "contracts/XershaFactory.sol:XershaFactory",
        "label": "poolTypes",
        "offset": 0,
        "slot": "6",
        "type": "t_mapping(t_address,t_enum(PoolType)1910)"
      },
      {
        "astId": 1939,
        "contract": "contracts/XershaFactory.sol:XershaFactory",
        "label": "allPools",
        "offset": 0,
        "slot": "7",
        "type": "t_array(t_address)dyn_storage"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_address)dyn_storage": {
        "base": "t_address",
        "encoding": "dynamic_array",
        "label": "address[]",
        "numberOfBytes": "32"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_enum(PoolType)1910": {
        "encoding": "inplace",
        "label": "enum XershaFactory.PoolType",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_address)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_address,t_enum(PoolType)1910)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => enum XershaFactory.PoolType)",
        "numberOfBytes": "32",
        "value": "t_enum(PoolType)1910"
      }
    }
  }
}