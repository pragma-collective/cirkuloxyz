{
  "language": "Solidity",
  "sources": {
    "contracts/InviteOnlyGroupRule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IGroupRule Interface\n * @notice Interface that all Lens Protocol group rules must implement\n * @dev Based on Lens Protocol documentation for custom group rules\n */\ninterface IGroupRule {\n    /**\n     * @notice Configure the rule for a specific group\n     * @param configSalt Unique configuration identifier (32 bytes)\n     * @param ruleParams Configuration parameters as key-value pairs\n     */\n    function configure(\n        bytes32 configSalt, \n        KeyValue[] calldata ruleParams\n    ) external;\n\n    /**\n     * @notice Called when admin adds a member\n     * @param configSalt Configuration identifier\n     * @param originalMsgSender Original transaction sender\n     * @param account Account being added\n     * @param primitiveParams Parameters from the group\n     * @param ruleParams Rule-specific parameters\n     */\n    function processAddition(\n        bytes32 configSalt,\n        address originalMsgSender,\n        address account,\n        KeyValue[] calldata primitiveParams,\n        KeyValue[] calldata ruleParams\n    ) external;\n\n    /**\n     * @notice Called when admin removes a member\n     */\n    function processRemoval(\n        bytes32 configSalt,\n        address originalMsgSender,\n        address account,\n        KeyValue[] calldata primitiveParams,\n        KeyValue[] calldata ruleParams\n    ) external;\n\n    /**\n     * @notice Called when someone tries to join\n     */\n    function processJoining(\n        bytes32 configSalt,\n        address account,\n        KeyValue[] calldata primitiveParams,\n        KeyValue[] calldata ruleParams\n    ) external;\n\n    /**\n     * @notice Called when someone tries to leave\n     */\n    function processLeaving(\n        bytes32 configSalt,\n        address account,\n        KeyValue[] calldata primitiveParams,\n        KeyValue[] calldata ruleParams\n    ) external;\n}\n\n/// @notice Key-value pair structure used by Lens Protocol\nstruct KeyValue {\n    bytes32 key;\n    bytes value;\n}\n\n/**\n * @title InviteOnlyGroupRule\n * @notice Lens Protocol Group Rule that validates invite codes\n * @dev Implements IGroupRule interface for on-chain validation\n * \n * This contract allows groups to be invite-only by:\n * 1. Backend registers invite codes on-chain (hashed for privacy)\n * 2. Users provide invite code when joining\n * 3. Contract validates code and marks as used (one-time use)\n * 4. Admins can still add members directly (override)\n */\ncontract InviteOnlyGroupRule is IGroupRule {\n    // ========== ERRORS ==========\n    error OnlyBackend();\n    error OnlyOwner();\n    error InviteNotFound();\n    error InviteExpired();\n    error InviteAlreadyUsed();\n    error InviteNotCancellable();\n    error InvalidAddress();\n    error InvalidInviteCode();\n    \n    // ========== EVENTS ==========\n    event InviteRegistered(\n        bytes32 indexed configSalt,\n        address indexed inviter,\n        bytes32 indexed inviteCodeHash,\n        uint256 expiresAt\n    );\n    \n    event InviteUsed(\n        bytes32 indexed configSalt,\n        address indexed invitee,\n        bytes32 indexed inviteCodeHash,\n        address inviter\n    );\n    \n    event InviteCancelled(\n        bytes32 indexed configSalt,\n        address indexed inviter,\n        bytes32 indexed inviteCodeHash\n    );\n    \n    event BackendUpdated(\n        address indexed oldBackend,\n        address indexed newBackend\n    );\n    \n    event RuleConfigured(bytes32 indexed configSalt);\n    \n    // ========== STORAGE ==========\n    \n    /// @notice Backend address authorized to register invites\n    address public backend;\n    \n    /// @notice Contract owner (can update backend address)\n    address public owner;\n    \n    /// @notice Mapping of configSalt -> inviteCodeHash -> invite data\n    /// @dev configSalt is unique per group, inviteCodeHash is unique per invite\n    mapping(bytes32 => mapping(bytes32 => InviteData)) public invites;\n    \n    /// @notice Invite data structure\n    struct InviteData {\n        address inviter;       // Address of person who created the invite\n        uint256 expiresAt;     // Expiration timestamp\n        bool used;             // Whether invite was used\n        address usedBy;        // Address that used this invite (set when used)\n    }\n    \n    // ========== MODIFIERS ==========\n    \n    modifier onlyBackend() {\n        if (msg.sender != backend) revert OnlyBackend();\n        _;\n    }\n    \n    modifier onlyOwner() {\n        if (msg.sender != owner) revert OnlyOwner();\n        _;\n    }\n    \n    // ========== CONSTRUCTOR ==========\n    \n    /**\n     * @notice Initialize contract with backend signer address\n     * @param _backend Address authorized to register invites\n     */\n    constructor(address _backend) {\n        if (_backend == address(0)) revert InvalidAddress();\n        backend = _backend;\n        owner = msg.sender;\n        \n        emit BackendUpdated(address(0), _backend);\n    }\n    \n    // ========== BACKEND FUNCTIONS ==========\n    \n    /**\n     * @notice Register a new invite for a group\n     * @dev Only callable by the designated backend address\n     * @param configSalt The configuration salt for the group\n     * @param inviter The address creating the invite\n     * @param inviteCodeHash The hash of the invite code\n     * @param expiresAt The expiration timestamp (0 for no expiration)\n     */\n    function registerInvite(\n        bytes32 configSalt,\n        address inviter,\n        bytes32 inviteCodeHash,\n        uint256 expiresAt\n    ) external onlyBackend {\n        if (inviter == address(0)) revert InvalidAddress();\n        if (inviteCodeHash == bytes32(0)) revert InvalidInviteCode();\n        \n        InviteData storage invite = invites[configSalt][inviteCodeHash];\n        \n        // Allow re-registration if not yet used\n        if (invite.used) revert InviteAlreadyUsed();\n        \n        invite.inviter = inviter;\n        invite.expiresAt = expiresAt;\n        invite.used = false;\n        invite.usedBy = address(0);\n        \n        emit InviteRegistered(configSalt, inviter, inviteCodeHash, expiresAt);\n    }\n    \n    /**\n     * @notice Cancel a registered invite and free storage\n     * @dev Only callable by the backend address. Deletes invite data to reclaim gas.\n     * @param configSalt The configuration salt for the group\n     * @param inviteCodeHash The hash of the invite code to cancel\n     * \n     * IMPORTANT: Cannot cancel invites that have already been used.\n     * This prevents issues with historical data and ensures audit trails.\n     * \n     * GAS OPTIMIZATION: Using `delete` frees storage and provides gas refund (~15k gas)\n     */\n    function cancelInvite(\n        bytes32 configSalt,\n        bytes32 inviteCodeHash\n    ) external onlyBackend {\n        InviteData storage invite = invites[configSalt][inviteCodeHash];\n        \n        // Validate invite exists\n        if (invite.inviter == address(0)) revert InviteNotFound();\n        \n        // Cannot cancel if already used (preserve audit trail)\n        if (invite.used) revert InviteNotCancellable();\n        \n        // Emit event BEFORE deletion (so we still have data to emit)\n        emit InviteCancelled(configSalt, invite.inviter, inviteCodeHash);\n        \n        // Delete invite data - this zeros out all fields and provides gas refund\n        delete invites[configSalt][inviteCodeHash];\n    }\n    \n    /**\n     * @notice Update backend signer address\n     * @dev Only callable by contract owner\n     * @param newBackend New backend address\n     */\n    function updateBackend(address newBackend) external onlyOwner {\n        if (newBackend == address(0)) revert InvalidAddress();\n        \n        address oldBackend = backend;\n        backend = newBackend;\n        \n        emit BackendUpdated(oldBackend, newBackend);\n    }\n    \n    /**\n     * @notice Transfer ownership to new address\n     * @dev Only callable by current owner\n     * @param newOwner New owner address\n     */\n    function transferOwnership(address newOwner) external onlyOwner {\n        if (newOwner == address(0)) revert InvalidAddress();\n        owner = newOwner;\n    }\n    \n    // ========== LENS PROTOCOL IGROUPRULE INTERFACE ==========\n    \n    /**\n     * @notice Configure rule for a specific group\n     * @dev Called by Lens Protocol when rule is added to group\n     * @param configSalt Unique configuration identifier\n     * \n     * NOTE: This is part of the IGroupRule interface.\n     * For now, we don't need any special configuration.\n     * ConfigSalt serves as unique identifier per group.\n     */\n    function configure(\n        bytes32 configSalt,\n        KeyValue[] calldata /* ruleParams */\n    ) external override {\n        emit RuleConfigured(configSalt);\n    }\n    \n    // Parameter keys (using Lens Protocol pattern)\n    /// @custom:keccak lens.param.inviteCode\n    bytes32 constant PARAM__INVITE_CODE = 0x5797e5205a2d50babd9c0c4d9ab1fc2eb654e110118c575a0c6efc620e7e055e;\n    \n    /**\n     * @notice Process a join request (IGroupRule interface)\n     * @dev Validates invite code and marks it as used\n     * @param configSalt The configuration salt for the group\n     * @param account The account attempting to join\n     * @param ruleParams Rule-specific parameters containing the invite code\n     */\n    function processJoining(\n        bytes32 configSalt,\n        address account,\n        KeyValue[] calldata /* primitiveParams */,\n        KeyValue[] calldata ruleParams\n    ) external override {\n        if (account == address(0)) revert InvalidAddress();\n        \n        // Extract invite code from params\n        string memory providedCode = _extractInviteCode(ruleParams);\n        if (bytes(providedCode).length == 0) revert InvalidInviteCode();\n        \n        // Hash the provided code\n        bytes32 providedCodeHash = keccak256(abi.encodePacked(providedCode));\n        \n        // Get the invite data using the hash as the key\n        InviteData storage invite = invites[configSalt][providedCodeHash];\n        \n        // Validate invite exists (if inviter is zero, invite was deleted/cancelled or never existed)\n        if (invite.inviter == address(0)) revert InviteNotFound();\n        \n        // Check if already used\n        if (invite.used) revert InviteAlreadyUsed();\n        \n        // Check expiration\n        if (invite.expiresAt != 0 && block.timestamp > invite.expiresAt) {\n            revert InviteExpired();\n        }\n        \n        // Mark as used and record who used it\n        invite.used = true;\n        invite.usedBy = account;\n        \n        emit InviteUsed(configSalt, account, providedCodeHash, invite.inviter);\n    }\n    \n    /**\n     * @notice Validate when admin tries to add a member\n     * @dev Empty implementation = ALLOW all admin additions\n     * \n     * WHY: Admins should be able to add members without invites.\n     * This gives admins an \"override\" capability for:\n     * - Emergency adds\n     * - Onboarding founding members\n     * - Recovering from issues\n     * \n     * HOW IT WORKS:\n     * - Function completes without reverting\n     * - Lens Protocol interprets this as \"validation passed\"\n     * - Admin can add member successfully\n     */\n    function processAddition(\n        bytes32 /* configSalt */,\n        address /* originalMsgSender */,\n        address /* account */,\n        KeyValue[] calldata /* primitiveParams */,\n        KeyValue[] calldata /* ruleParams */\n    ) external pure override {\n        // Empty implementation = allow action\n        // No revert = validation passed\n    }\n    \n    /**\n     * @notice Validate when admin tries to remove a member\n     * @dev Empty implementation = ALLOW all removals\n     * \n     * WHY: Admins should always be able to remove members.\n     * This is a safety mechanism - groups should never be locked\n     * with bad actors that can't be removed.\n     */\n    function processRemoval(\n        bytes32 /* configSalt */,\n        address /* originalMsgSender */,\n        address /* account */,\n        KeyValue[] calldata /* primitiveParams */,\n        KeyValue[] calldata /* ruleParams */\n    ) external pure override {\n        // Empty implementation = allow action\n    }\n    \n    /**\n     * @notice Validate when someone tries to leave the group\n     * @dev Empty implementation = ALLOW anyone to leave anytime\n     * \n     * WHY: Users should always have the right to leave a group.\n     * This prevents groups from becoming \"traps\" that lock users in.\n     * It's a fundamental user freedom.\n     */\n    function processLeaving(\n        bytes32 /* configSalt */,\n        address /* account */,\n        KeyValue[] calldata /* primitiveParams */,\n        KeyValue[] calldata /* ruleParams */\n    ) external pure override {\n        // Empty implementation = allow action\n    }\n    \n    // ========== VIEW FUNCTIONS ==========\n    \n    /**\n     * @notice Extract invite code from KeyValue parameters\n     * @dev Helper function to parse Lens Protocol params\n     * @param params Array of KeyValue pairs\n     * @return Invite code string\n     */\n    function _extractInviteCode(KeyValue[] calldata params) private pure returns (string memory) {\n        for (uint256 i = 0; i < params.length; i++) {\n            if (params[i].key == PARAM__INVITE_CODE) {\n                return abi.decode(params[i].value, (string));\n            }\n        }\n        return \"\";\n    }\n    \n    /**\n     * @notice Get invite details by invite code hash\n     * @param configSalt Group configuration identifier\n     * @param inviteCodeHash Hash of the invite code\n     * @return inviter Address that created the invite\n     * @return expiresAt Expiration timestamp\n     * @return used Whether the invite was used\n     * @return usedBy Address that used the invite (if used)\n     */\n    function getInvite(\n        bytes32 configSalt,\n        bytes32 inviteCodeHash\n    ) external view returns (\n        address inviter,\n        uint256 expiresAt,\n        bool used,\n        address usedBy\n    ) {\n        InviteData storage invite = invites[configSalt][inviteCodeHash];\n        return (invite.inviter, invite.expiresAt, invite.used, invite.usedBy);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}